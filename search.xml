<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>组件收集工具—ComponentAutoCollector</title>
      <link href="/2025/10/26/ComponentAutoCollector/"/>
      <url>/2025/10/26/ComponentAutoCollector/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想起之前写过的一个组件自动化收集工具，这里分享出来。</p><p>链接: <a href="https://pan.baidu.com/s/1wHox7gMie_XwkanFZeJ7Yg?pwd=bnqd">https://pan.baidu.com/s/1wHox7gMie_XwkanFZeJ7Yg?pwd=bnqd</a> 提取码: bnqd </p><h2 id="一-概念和作用"><a href="#一-概念和作用" class="headerlink" title="一. 概念和作用"></a>一. 概念和作用</h2><p>这是一个组件自动化绑定工具。在UI页面的开发中，自动收集 UI 组件并生成对应的序列化字段。其核心逻辑在于分析场景中游戏对象的命名规范，自动为 MonoBehaviour 脚本添加、更新和删除组件引用字段。</p><h2 id="二-书写目的"><a href="#二-书写目的" class="headerlink" title="二. 书写目的"></a>二. 书写目的</h2><ol><li>提高开发效率，减少反复定义和拖拽耗时。</li><li>规范化命名格式，支持根据名称快速定位，以增加可读性和复查便捷性。</li></ol><h2 id="三-使用方式"><a href="#三-使用方式" class="headerlink" title="三. 使用方式"></a><strong>三. 使用方式</strong></h2><ol><li><p><strong>标记 UI 节点</strong></p><p> 在 Hierarchy 视图中为需要收集的节点按特定前缀命名，比如想要收集button组件，则是“@_btn_xxxx” 的形式。其格式拆解为：</p><ul><li>@ 表示此节点需要参加组件的收集。其中@和$的区别在于，$下面的子节点不会参与当前脚本的组件收集，而其下的节点则是只参与$修饰节点其本身的收集。</li><li>btn 表示想要收集组件的简称</li><li>xxxx 则是自定义的命名</li></ul> <img src="/img/Component_1.png" class="post-image" /> </li><li><p><strong>触发自动收集流程</strong></p><ul><li>在 Inspector 面板中右键点击目标 MonoBehaviour 组件的右上侧三个点</li><li>选择 “Auto Collect UI Components” 选项，即可开始收集。</li></ul><p> 流程注意：这里收集的流程会分为两步，第一步会根据命名自动生成对应的字段到脚本上，然后进行编译；第二步则是把组件赋值到对应的字段上去。</p><p> 因此要执行两次，规范好命名后，执行一次，等待编译(如果有增删才会执行编译)，编译完成后，执行第二次。</p> <img src="/img/Component_2.png" class="post-image" /></li><li><p><strong>查看结果与核对</strong></p><ul><li>控制台会根据操作展示当前改动的结果</li><li>最终收集到的组件会在对应脚本上呈现出对应的字段定义，并会被region区域划分，这一部分并不需要，也请不要进行手动修改。</li></ul> <img src="/img/Component_3.png" class="post-image" /> <img src="/img/Component_4.png" class="post-image" /></li><li><p><strong>关于自定义组件的收集和非UI页面的拓展</strong></p><p> 按理说，想要让更多组件支持被收集，只需要不断拓展其支持采集的组件检索即可。此外，此组件并非只限于UI页面的使用，非UI页面组件的收集也是支持的，同样拓展收集的组件类型即可。</p><p> 但这里目前仅提供基础UGUI组件支持即可，如果有通用的，直接添加也没有任何问题。</p> <img src="/img/Component_5.png" class="post-image" /></li></ol><h2 id="四-拓展考量"><a href="#四-拓展考量" class="headerlink" title="四. 拓展考量"></a><strong>四. 拓展考量</strong></h2><p>目前UI页面针对射线并没有对应的强制限制规范，游戏里UI包含大量冗余的射线使用且使用的射线并未被掏空Mesh，这会照成冗余的性能消耗。<br>后续可拓展此工具，针对这一方面做出限制和拓展。</p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件收集 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈红点树与分帧</title>
      <link href="/2025/05/18/redPointTree/"/>
      <url>/2025/05/18/redPointTree/</url>
      
        <content type="html"><![CDATA[<h2 id="基础结构总览"><a href="#基础结构总览" class="headerlink" title="基础结构总览"></a>基础结构总览</h2><p>参考这篇文章 <a href="https://zhuanlan.zhihu.com/p/85978429">用树实现客户端红点系统</a> ，在说明红点系统的结构的时候,独立的将整个系统分为了独立的三个部分：结构层，驱动层和表现层。<br>接下来我们也会以这样的结构来进行阐述。</p><p>这篇文章的讲明了基本的红点树的结构和思路.</p><ol><li>结构层<br>对于树的构建，通过枚举字符串命名去确定树节点的数据来源，然后整合数据区初始化树的数据。<br>而它与驱动层的关联可以体现在节点的两个方面：</li></ol><ul><li>定义一个委托，用于外面注册传递红点数量发生变化时候的自定义回调函数。方便实现每个节点的红点数量变化的自定义内容。</li><li>封装一下节点的红点数量变化的接口，并把功能和委托调用进行关联。</li></ul><ol start="2"><li><p>驱动层<br>驱动层是用来提供给外界修改对应节点红点数量以触发其回调事件用的，我们往往会在管理器里面封装成接口，供外部调用。</p></li><li><p>表现层<br>表现层来自UI自定义设置，案例里面给的能够在初始化的时候就设置好所有的红点数据和页面信息。当然有不能完全展示之类的其他情况，这个我们后面会说。</p></li></ol><p>通过这种实现形式我们能做到的是：</p><ul><li>整个系统，三个层面的逻辑分明，各司其职。</li><li>红点的数据来源和控制和数的结构以及整个红点系统并没发生耦合。</li></ul><p>但是看完之后你可能会产生一些觉得疑惑的点：</p><ol><li>对于树构建的写法是否还可以进行优化？</li><li>是否需要像DEMO演示一样一开始就需要拿到所有红点数据？</li><li>实际开发中，不可能在一开始就初始化好所有的UI页面，对于未初始化的页面和需要动态生成的item这些，其页面功能显示和数据是如何处理的？</li></ol><h2 id="重点思路"><a href="#重点思路" class="headerlink" title="重点思路"></a>重点思路</h2><h3 id="使用前缀树构建树节点"><a href="#使用前缀树构建树节点" class="headerlink" title="使用前缀树构建树节点"></a>使用前缀树构建树节点</h3><blockquote><p>前缀树，是一种多叉树，多用于对字符串的保存和文本的索引，具有相同前缀的字符串，拥有相同的父节点，结合合理的索引方式，可以高效便捷的查找到目标文本内容。<br>通过将红点项转化为路径，再将路径和当前红点项的红点数量存储于节点中，可以十分方便的供其他模块进行查询和管理。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/85978429">用树实现客户端红点系统</a>这篇文章中，我们其实也能看见把枚举路径字符串给切割成数组去初始化树 和 在搜索查找的时候都是通过把字符串才分节点列表去查找的。<br>只是对于每一个字符串的切割，每需要得到一个我们想要的节点的时候就要进行一次切割，当然这种形式也可以进行优化，比如使用可变传输，传入逐级的单项字符串路径等。</p><h3 id="红点系统的显示不应该依赖于UI"><a href="#红点系统的显示不应该依赖于UI" class="headerlink" title="红点系统的显示不应该依赖于UI"></a>红点系统的显示不应该依赖于UI</h3><p>正如上面我们考虑到的疑惑3一样，对于未初始化或者需要动态生层的页面，但是根据路径层层往上的话，最终还是会来需要显示的页面，比如主页面这种。<br>这其实就是数据和页面显示的分离，当页面没有被初始化的时候，如果我们需要显示其对应路径的红点，其实我们只需要有对应的节点的数据就可以。<br>也就是说如果需要显示红点，其页面可以不初始化或者生成，但是我们需要有对应节点的数据。<br>而主页面这种，处于路径中的节点，在其页面被初始化的使用就应该动态的去获取经过其节点的红点数据，从而进行显示。<br>所以概括一下就是 “UI红点基于数据动态显示红点，而红点的数据不依赖UI的页面情况”。</p><p>首先理解这个思想，然后基于这个思想，在说一下像是邮件这种可能在运行时候动态创建的显示需求，其红点要如何处理。<br>要实现这样的需求，首先对于其节点的构建我们就不能够写死，我们需要实现基本的路径不变，而能够路径中部分的发生改变，因此需要为动态实例设置复合的键名，我们可以做出如下定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> MAIL_PATH_PREFIX = <span class="string">&quot;Mail.&#123;邮箱ID&#125;.&#123;邮件ID&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p>当我们受到服务器或者其他来源的数据，比如邮箱1里面的邮件101，其路径就可以是： “Mail.1.101”。</p><p>根据这样的节点信息，我们就可以通过调用结构层注入数据，去动态的创建对应的红点树节点，因为结构层内置的逻辑会刷新其上层红点数量信息，从而实现动态添加。<br>放在这个案例中就是我们的页面目前显示着的是主页面，邮件页面根本没有被初始化，但是主页面存在邮件的按钮入口，此按钮入口是注册了对应邮件红点树节点的回调函数，并关联了自身的红点表现效果。此时邮件信息更新，对应深层的红点树节点的红点数量得到了刷新，而层层往上进行通知，最终通过驱动层关联上了主页面“邮件”按钮的红点变化表示，因此其红点表示能正常显示。<br>而当我们点击邮件按钮，邮件页面初始化的时候就可以进行动态绑定和红点数据检查，从而实现邮件页面的红点显示。这个效果对于使用无限列表的邮件Item也是一样的逻辑。</p><h3 id="红点数量刷新的优化"><a href="#红点数量刷新的优化" class="headerlink" title="红点数量刷新的优化"></a>红点数量刷新的优化</h3><p>当一个节点存在多个子节点，且其多个子节点在同一时间需要更新数据的时候，如果都去逐个通知其父节点，就会造成多次冗余的刷新。这种情况在类似背包道具大量获取的情况下会出现。<br><a href="https://zhuanlan.zhihu.com/p/453516850">用树实现客户端红点系统</a>这篇文章中作者为此创建了一个用来存储需要更新的父节点的“脏池子”，当节点数量变化导致其父节点的红点数量需要更新的时候，就会把对父节点做脏标记，当一下帧的Update方法驱动调用的时候，遍历截止当前帧的所有被标记位脏的父节点，由父节点来主动查询自己所需的节点值，如果节点值发生变化，则响应外部注册的监听方法。<br>这就是经典的“脏标记+延迟更新”的手法，可以有效的减少刷新次数，提高效率。</p><h3 id="处理红点逻辑需要依赖多个条件组合"><a href="#处理红点逻辑需要依赖多个条件组合" class="headerlink" title="处理红点逻辑需要依赖多个条件组合"></a>处理红点逻辑需要依赖多个条件组合</h3><p>这个需求可以从两个方面进行考虑</p><ul><li><p>拓展红点系统，无论是考虑拓展红点的字符串表达式并添加对应的解析器，还是选择通过配表的形式给对应红点路径节点添加条件，其根本核心就是在红点系统里面拓展条件判定功能，也就是说在刷新红点数据的时候会同时通过条件判断系统去判断给出的条件是否满足，只有满足了才会进行此节点红点数据的刷新。<br>这种就是用来处理数据会早一步拿到手，而条件判定的功能只是限制手段。</p></li><li><p>拓展条件判定功能模块。比如当玩家等级提升派发事件的时候，再去刷新对应的红点数据，也就是达成这个条件之后，红点的数据才会拿到手。</p></li></ul><p>如果只是简单的红点树拓展的话，第二种方式其实够用了，实际项目中很多也用的是第二种形式。</p><h2 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h2><p>首先 分帧的原理一句话概括就是把一帧里面的内容分到几帧里面去执行。为了实现这个效果其实只需要做到以下几个点就行了：</p><ol><li>把要执行的方法缓存下来，储存到缓存器中</li><li>执行缓存器里面的方法，执行到限定的数量之后，不再执行，把它放到下一帧去</li></ol><p>说到这里可能就有人会说，这样的会不会导致页面刷新出现延迟的情况？<br>答案是会的，当数量实在是太多的，如果采用这种形式，就必然会出现这样的问题，而相比把这众多的量的刷新都放在一帧里面去所造成的性能问题，这更倾向于一种妥协。<br>也因此，合理的调整好每一帧执行的数量便显得至关重要。</p><p>为了实现这样的功能效果，我们首先就需要制定对应的规则，也就是要确定“哪个模块的功能，一帧限制执行几次” 这两个问题。</p><p>首先说第二个问题，原则上这里我们可以通过配表和枚举来做，其实配表也需要通过枚举，且这本来来就是前端的内容，不需要策划掺一脚，因此我们采用枚举来做就好。</p><p>那么第一件事，使用枚举定义好每个需要分帧的功能模块的定义和其对应限制分帧的次数</p><p>比如说，我们可以做出如下定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> FrameTypeDefine = &#123;</span><br><span class="line">    RedPoint_BagItem = &#123;<span class="number">1001</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，1001代表这个功能模块的ID，2代表限制一帧执行的次数。</p><p>那么既然我们的待执行事件都是添加列表缓存起来，然后限制执行的，接下来我们就应当考虑如何封装执行分帧的方法，也就是需要把我们要执行的内容添加到待执行列表中去。<br>这里主要要考虑 对应执行的方法，执行的对象，传参，以及执行次数。<br>这里用Lua来表示一个类型的缓存数据结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cacheData = &#123;</span><br><span class="line">    [<span class="number">1001</span>] = &#123;</span><br><span class="line">        funcs = &#123;</span><br><span class="line">            [<span class="number">114514</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="keyword">end</span>,</span><br><span class="line">            [<span class="number">114515</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        &#125;,</span><br><span class="line">        objs = &#123;</span><br><span class="line">            [<span class="number">114514</span>] = &#123; <span class="string">&quot;模拟对象1&quot;</span> &#125;,</span><br><span class="line">            [<span class="number">114515</span>] = &#123; <span class="string">&quot;模拟对象2&quot;</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        params = &#123;</span><br><span class="line">            [<span class="number">114514</span>] = &#123;</span><br><span class="line">                param1 = <span class="number">1</span>,</span><br><span class="line">                param2 = <span class="number">2</span>,</span><br><span class="line">                param3 = <span class="number">3</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            [<span class="number">114515</span>] = &#123;</span><br><span class="line">                param1 = <span class="number">4</span>,</span><br><span class="line">                param2 = <span class="number">5</span>,</span><br><span class="line">                param3 = <span class="number">6</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        frameCount = <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，1001表示功能模块，funcs表示需要执行的方法，objs表示方法执行的对象，params表示方法执行的参数，frameCount表示限制执行的次数。而114514和114515则是执行此方法判断的唯一标识。</p><p>在确保拿到正确的缓存数据后，我们接下来就需要把它加入待执行的列表中去。<br>注意，这里准确来说把当前的缓存数据缓存下来，加入待执行列表后，会是在下一帧去开始执行这个功能。当执行了对应的次数之后，如果没有执行完成，则会放到下一帧去，否则只是会移除当前的数据。</p><p>把它关联到红点的话，其实就是，当我们需要刷新红点的时候，我们并不直接调用对应红点模块的刷新方法，而是把它注册到分帧事件里面去，通过分帧的机制，去执行这样的一个功能，从而达到性能优化的目的。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/85978429">基本思路-用树实现客户端红点系统</a></li><li><a href="https://zhuanlan.zhihu.com/p/453516850">进阶版思路-基于TrieTree（前缀树）的红点系统</a></li><li><a href="https://blog.csdn.net/linxinfa/article/details/121899276">lua实现红点系统</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> RedPoint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红点树 </tag>
            
            <tag> 分帧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于状态机的一些注意点</title>
      <link href="/2025/05/18/fsm/"/>
      <url>/2025/05/18/fsm/</url>
      
        <content type="html"><![CDATA[<h2 id="分层状态机"><a href="#分层状态机" class="headerlink" title="分层状态机"></a>分层状态机</h2><p>这里说一个分层状态机可能会被混淆的点。</p><p>分层状态机（HSM）是有限状态机（FSM）的扩展，因为它将状态分了层次，并进行了对应的“分类”，也就是一个大状态里面可能包含着多个小状态，这些大状态是小状态层层继承下来的子类，我们在最终跳转的时候可能更多只会关注外面“大状态的变化”，而不用去考虑具体的子状态的变化，因为内部具体的“小状态”会在其内部处理其自己的跳转逻辑。</p><p>重点在于，分层状态机解决的是传统有限状态机当状态繁多时候的状态功能和跳转维护问题，也就是我们所说的“状态爆炸”问题。它是将各个状态通过树形的层次组织起来，并通过分类来进行抽离，将同类型的各个“小状态”组合起来看做一个“大状态”，从而解决问题<br>但相比有限状态机，分层状态机通过层级组织优化了状态复用和逻辑结构，其特性并没有发生改变，一个状态机同时只能在一个状态这一点并没有发生变化，千万不要混淆这一点。</p><h2 id="并发状态机"><a href="#并发状态机" class="headerlink" title="并发状态机"></a>并发状态机</h2><p>并发状态机时由多个独立但协同工作的状态机组成，共同配合实现功能的一种状态机。<br>对于每个状态机我们是按照需求的关注点去进行分离的，比如人物的基本移动和人物持武器这两个部分的功能就可以进行分离来做。且注意各个状态机都独立维护其自己的逻辑，两者的逻辑都相对独立。<br>但这里可能会引申出一个疑问，如果状态机之间需要交互怎么办？<br>确实人物控制和持武器的功能是极有可能存在需要交互的地方的，这种情况我们可以通过粗糙的if检测来做，也可以通过万能的事件分发，也就是状态机内部的事件通信机制来进行实现。<br>之所以说是状态机内部的事件通信是因为这里其实有必要可以实现一下，毕竟当事件系统总线里面的消息数量过多的话是会影响性能的。</p><h2 id="可共存的多状态和状态切换的判断"><a href="#可共存的多状态和状态切换的判断" class="headerlink" title="可共存的多状态和状态切换的判断"></a>可共存的多状态和状态切换的判断</h2><p>的确很多地方都在说状态内功能执行的重要性，但是状态切换判断同样也是一个不可忽视的重点。<br>上面我们所说的有一个重点便是：一个状态机一次只能存在一个状态。<br>这里我们可能需要暂时放一下这个点，因为实际的项目开发中是可能存在需要一个角色身上同时存在多个状态的情况的。</p><p>这种情况需要换个角度思考一下问题，比如一个聊天的状态和一个坐下的状态。如果我们出现了希望来聊天的状态能够坐下的情况，按照一般的思维我们可能希望存在一个“聊天坐下”的状态，也就是在这三个状态之间进行切换，并实现每个状态的功能。</p><p>但这里如果我们换一下视角，还是两个状态————聊天和坐下。但是我们让这两个状态能够共存，也就是说一个角色同时处于两个状态，并根据这种情况去执行功能。</p><p>说到这里你可能会觉得奇怪，这和上面说到的分层和并发本质并不是一回事，把它成为“状态叠加设计”的说法可能更合适一点，而这种设计可以应用到分层和并发等具体的状态机形式里面去。</p><p>这种形势下的状态之间的切换往往存在三种情况：</p><ol><li>能够共存存在且互不冲突</li><li>会覆盖之前的状态</li><li>互斥，不能切换到对应的状态</li></ol><p>那么按照这种形式，我们可以如何去管理一个角色身上的状态，并去执行对应的功能呢？<br>存在一些使用多状态判断的项目，其逻辑可能并不会直接写在状态里面，而是在别处实现。而状态判断的意义在于功能执行的限制和保障。<br>这可能就会变成一个单纯的“状态冲突”判断的组件。<br>当然，这并不意味着就不能以状态机为核心去书写对应的逻辑。把逻辑写在组件和动作事件里面去固然不错，但把对应状态的逻辑内聚在对应状态里面同样是一种不错的形式。这个就要根据项目实情仁者见仁智者见智了。</p><p>以及在协同开发中，也可能存在前端本地需要本地进行状态切换，而不需要同步给其他人的情况，这种情况我们就可以专门维护一个前端本地的状态列表去进行实现，但是在更新状态的时候需要及时把对应的冲突状态给去掉。</p><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><h3 id="不当操作和过度设计"><a href="#不当操作和过度设计" class="headerlink" title="不当操作和过度设计"></a>不当操作和过度设计</h3><ul><li>有限状态机的“状态爆炸”。这个点在上面已经反复说明过了，在考虑到简单状态无法实现的时候一定要开始从设计层面上进行修改了，比如考虑层次状态机，而不是硬堆状态。</li><li>层次状态机的过度分层。我们一般建议的是层级分个3层就差不多了，4层已经是顶天了，再往上就会导致状态关系难以追踪，其带来的不仅是调试上的困难，还有后面功能维护的困难。</li><li>并发状态机的过度交互。多个状态机中的交互在一些情况下是必要的，在实现这一步的时候就要考虑到绝对不能让状态之间的逻辑给耦合高了。用内部事件是一种方式，如果不用的话，一定要注意这一点。</li></ul><p>归根结底，其实在做的时候我们秉持最基本的设计开发原则就能减少很多错误了，上面这些其实也就是基本原则的体现，比如单一职责，事件驱动等。</p><h3 id="状态间共享数据需要额外设计"><a href="#状态间共享数据需要额外设计" class="headerlink" title="状态间共享数据需要额外设计"></a>状态间共享数据需要额外设计</h3><ul><li>“黑板模式”。也就是GF里面的数据缓存和获取的形式进行传递，这就是我们所说的“黑板模式”。</li><li>数据传递，切换的时候传递进去就行。</li><li>事件通信。万能的事件可以解决一切问题。</li><li>以状态机做中介传递。这种不是很推荐，把数据冗余在状态机里面的话，有可能会造成混乱。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://gpp.tkchu.me/state.html">游戏设计模式-状态模式</a></li><li><a href="http://www.aisharing.com/archives/393">层次化状态机的讨论</a></li><li><a href="https://www.drflower.top/posts/9c0788d1/">GF解析-状态机(花桑)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> FSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象池设计模式</title>
      <link href="/2025/04/27/objectPool/"/>
      <url>/2025/04/27/objectPool/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个相当经典的设计模式。因为项目中遇到一些关于对象池的问题，干脆就在这里整一下相关的知识点吧。</p><h2 id="为什么需要对象池"><a href="#为什么需要对象池" class="headerlink" title="为什么需要对象池"></a>为什么需要对象池</h2><p>对象池主要解决两个核心问题：一是避免频繁实例化&#x2F;销毁对象带来的GC压力，二是减少内存碎片化。</p><p>就拿最简单明了的子弹来进行说明，如果游戏里面的枪械，我们希望它能够频繁的射出各种类型的子弹，那么使用最直接的形式————&gt;需要的时候生成，不需要的时候销毁掉。这样做当然可以实现，但是这样做会有什么问题呢？<br>首先不难看出这样的效率低。我们当前不需要的就只能销毁掉，无法被拿出再次利用，每次都得走一遍重复的创建效果流程，这是完完全全的铺张浪费，此外如果是Unity的话，Destroy后的对象即使被销毁后，仍然可能残留在内存块中无法被复用，更别提这样大量频繁的操作会带来多少的开销了。</p><p>除此之外，这种形式还有可能造成严重的内存碎片化。</p><h2 id="什么是内存的碎片化"><a href="#什么是内存的碎片化" class="headerlink" title="什么是内存的碎片化"></a>什么是内存的碎片化</h2><p>内存碎片化是指物理内存空间被分割成大量不连续的小块，导致即使总空闲内存足够，也无法满足较大内存的连续分配请求。<br>内存的碎片化可以分为两类：外部的碎片化和内部的碎片化。我们这里主要阐述外部的碎片化。</p><p>这里直接借用《游戏设计模式》中的图来呈现，一目了然。<br><img src="/img/object-pool-heap-fragment.png" class="post-image" /></p><p>假设内存中有 3 个空闲块：[10MB] [被占用] [5MB] [被占用] [20MB]，但程序需要分配 30MB 连续内存，此时即使总空闲内存是 35MB，仍然无法分配。</p><p>为什么说频繁地生存消耗会导致内存的碎片化？<br>一句话概括就是动态内存分配和释放的不可预测性。游戏中的不同资源可能需要不同大小的内存块，比如上面说的“各种类型的子弹”，每种子弹需要的空间并不是一样的。较小的内存请求可能会导致较大的内存块被分割成多个小块，从而增加外部碎片化的风险。也因此，当游戏频繁创建销毁的时，内存管理器无法高效地维护连续的内存空间，就会最终导致内存被分割成许多小块。想象一下猫和老鼠里面的奶酪，上面的空洞就是被占用的内存块，它们会把完整的内存进行切割成不同的小块，而无法连续利用。</p><p>还是再说一下Unity的Instantiate和Destroy的情况。当我们使用Instantiate去进行生成和初始化的时候，会立刻进行空间分配，而当这个GO被Destroy的时候，Unity会将它标记为“可被回收”，但这只是被标记，需要等待下一次GC进行回收，这期间就会出现即使GO被所谓的“销毁”，但是其空间仍然无法被复用的情况。<br>那我用DestroyImmediate不就行了吗？确实DestroyImmediate可以立刻销毁，但是这种形式也是有其对应的代价的，这里不详细展开。</p><blockquote><p>哪怕碎片化发生得不频繁，它也仍会逐渐把堆变成有空洞和裂隙的不可用泡沫，最终完全无法运行游戏。</p></blockquote><p>内存碎片化相关更多的的可以查看参考文档。</p><p>是时候引出我们的主角————对象池模式。通过使用对象池可以有效避免频繁的创建和销毁，减少gc，预加载等开销，提高内存的利用率等</p><h2 id="如何设计一个的对象池"><a href="#如何设计一个的对象池" class="headerlink" title="如何设计一个的对象池"></a>如何设计一个的对象池</h2><p>关于对象池的概念和使用这些就不多赘言了，感兴趣可以从参考文档中找到入口。这里主要介绍一下如何设计一个好的对象池。</p><h3 id="对象池的基本实现"><a href="#对象池的基本实现" class="headerlink" title="对象池的基本实现"></a>对象池的基本实现</h3><p>一个对象池最基本的功能就是能提供和缓存某一类型的对象。<br>当外部需要这个类型的对象的时候，如果池中有空闲的对象，就直接从池中取出，否则就创建一个新的对象。当对象不再需要时，就将其放回池中，以便下次使用。<br>如果能实现这一点，就相当于实现了一个基本的对象池。</p><p>这里我们参考GF，对这部分感兴趣可以直接参考文档里面的链接。</p><p>在ReferenceCollection中，表示每一个类型的池子。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本定义，以队列形式存储对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="title">Queue</span>&lt;<span class="title">IReference</span>&gt; m_References</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> Type m_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对应类型的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Acquire</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : <span class="keyword">class</span>, IReference, <span class="keyword">new</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(T) != m_ReferenceType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Type is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_UsingReferenceCount++;</span><br><span class="line">    m_AcquireReferenceCount++;</span><br><span class="line">    <span class="keyword">lock</span> (m_References)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_References.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (T)m_References.Dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_AddReferenceCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params">IReference reference</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    reference.Clear();</span><br><span class="line">    <span class="keyword">lock</span> (m_References)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_EnableStrictCheck &amp;&amp; m_References.Contains(reference))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;The reference has been released.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_References.Enqueue(reference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_ReleaseReferenceCount++;</span><br><span class="line">    m_UsingReferenceCount--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给池中添加对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">int</span> count</span>) <span class="keyword">where</span> T : <span class="keyword">class</span>, IReference, <span class="keyword">new</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(T) != m_ReferenceType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Type is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lock</span> (m_References)</span><br><span class="line">    &#123;</span><br><span class="line">        m_AddReferenceCount += count;</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_References.Enqueue(<span class="keyword">new</span> T());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除池中对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">int</span> count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (m_References)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; m_References.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            count = m_References.Count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_RemoveReferenceCount += count;</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_References.Dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而如果要管理这种每一个类型的池子，参考ReferencePool，则用一个简单的字典定义即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;Type, ReferenceCollection&gt; s_ReferenceCollections = <span class="keyword">new</span> Dictionary&lt;Type, ReferenceCollection&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优化内存访问效率"><a href="#优化内存访问效率" class="headerlink" title="优化内存访问效率"></a>优化内存访问效率</h3><h4 id="预分配策略"><a href="#预分配策略" class="headerlink" title="预分配策略"></a>预分配策略</h4><p>在空闲的时候去预加载一些，通过进行预分配，可以避免运行时动态分配造成的卡顿。<br>当然需要根据游戏场景分析，通常预加载预计峰值用量的70-80%。</p><h4 id="冷热对象分离策略"><a href="#冷热对象分离策略" class="headerlink" title="冷热对象分离策略"></a>冷热对象分离策略</h4><p>在一个池子里面再去细分“热池”和“冷池”，根据对象使用频率进行分级管理，以提高内存的访问效率。<br>同一个池子里面，可能存在许多的缓存对象，当我们频繁从池子里面取的时候，便有可能一些对象会被高频使用，而一些对象则会被低频使用。其判断标准根据上一次使用的时间来定，可以每隔一段时间进行一次检查，进行对象的池内迁移。针对高频使用的我们在池子里面把对象细分到“热池”里面，而针对低频使用的我们在池子里面把对象细分到“冷池”里面。我们取的时候，先从热池取，如果没有，再从冷池取，如果没有，再去创建一个新的对象。</p><p>这里要说一个东西叫做 缓存命中率，它是我们从池子里面取对象的时候，从热池还是冷池取，从热池获取叫做缓存命中，从冷池取或者新建对象叫做缓存未命中。<br>所以我们可以得到计算公式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> totalRequests = hotHits + coldHits + newCreations;</span><br><span class="line"><span class="built_in">float</span> hitRate = (<span class="built_in">float</span>)hotHits / totalRequests;</span><br></pre></td></tr></table></figure><p>为了保证缓存的高效性，我们需要考虑根据缓存命中率来动态调节热池的大小</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustPoolSizes</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">float</span> hitRate = (<span class="built_in">float</span>)hotHits / (hotHits + coldHits);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hitRate &gt; <span class="number">0.7f</span>) &#123;</span><br><span class="line">        hotPoolMaxSize = Mathf.Min(hotPoolMaxSize + <span class="number">5</span>, maxHotPoolSize);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hitRate &lt; <span class="number">0.5f</span>) &#123;</span><br><span class="line">        hotPoolMaxSize = Mathf.Max(hotPoolMaxSize - <span class="number">3</span>, minHotPoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而联系到上面预分配，当热池里面剩余容量不足约30%的时候，且可能存在大量使用的情况下，我们就可以预加载，从冷池里面进行获取。</p><p>当物理内存不足时，系统会根据特定策略(LRU,LFU)将最久未使用的或者说使用频率最低的部分内存页进行换出。通过冷热分离的形式，热池里面的对象在CPU中因为会被频繁使用，所以会常驻L1&#x2F;L2缓存中，而冷池则可能仅在L3或者主存里面。采用这种形式可以减少获取获取热对象的延迟，减缓获取冷对象的延迟，但整体获取的平均延迟是减少了的，也因此可以减少gc的触发频率。</p><h4 id="其他优化策略"><a href="#其他优化策略" class="headerlink" title="其他优化策略"></a>其他优化策略</h4><ul><li>定时释放。当池子里面的物体存在固定时间没有被使用的时候，就进行释放。</li><li>数据统计。统计当前池中的对象数量，释放数量，缓存数量等等。这些可以方便即时查看以便查找问题。</li><li>增加锁定功能。当我们希望某个物体长期不使用也不会被释放，被需要的就可以快速响应的时候，可以锁定对应的物体。比如主页面。</li><li>拓展存储形式。比如通过调整key值的分配和基类的缓存去实现一个类型的池子中可以缓存都是这个类型但是细节有区分的物体。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://gpp.tkchu.me/object-pool.html">游戏设计模式-对象池模式</a></li><li><a href="https://blog.csdn.net/qq_33060405/article/details/144838273">外部碎片化</a></li><li><a href="https://blog.csdn.net/qq_33060405/article/details/144838285">内部碎片化</a></li><li><a href="https://www.drflower.top/posts/9c0788d1/">GF解析-引用池(花桑)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ObjectPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈实体组件模式</title>
      <link href="/2025/04/13/entityAndComponent/"/>
      <url>/2025/04/13/entityAndComponent/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文说一下在传统设计模式下的实体组件模式，它的设计模式和ECS架构里面的设计有很大的差异。但这里不会就差异进行展开，而是着重说明前者的设计理念，拓展以及这种模式下可能出现的问题点。当然，个人见解，有问题欢迎指出。</p><h2 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h2><p>首先要明确一点在面向对象的开发中，存在一个及设计原则便是“组合优于继承”。<br>为了了解到这个原则，我们可以举个例子来说明一下。<br>有一天策划说要做三种类型的哥布林，分别是战士哥布林，法师哥布林，和弓手哥布林。如果按照面向对象的思维，我们可能的处理方式是：书写一个哥布林基类，然后创建三个派生类，分别是战士哥布林，法师哥布林，和弓手哥布林。根据每个功能类型不一致，去书写各自的功能，比如战士哥布林只能近战，法师哥布林可以释放法术攻击，弓手哥布林可以进行远射击。这样似乎能完美的解决需求，但是如果后面版本迭代了，策划大人又发话了，再设计一个新的功能，战士哥布林可以进行魔法功能，法师哥布林可以发射远程魔法箭。那么作为卑微的程序，按照传统的面向对象的思维，是不是就需要再创建一个魔法战士哥布林类型以及一个魔弓手哥布林类型？显然这样做需求也得到了满足。但是后面吊策划又发话了，要设计各种各样的哥布林，那些元素和属性要能够自由搭配，那如果还是按照面向对象继承的思维，那得把所有的情况全部列举出来，然后挨个去写派生类，这还不是最难受的，如果再涉及到任何这些关联内容的功能修改，这也意味着你要去维护每一个你写的类型，这意味着极大的维护成本和超多的工作量。</p><p>而如果使用组合的形式，我们可以声明三个组件，分别是近战组件，远程攻击组件，魔法攻击组件，通过自由搭配添加，只有哥布林挂在了近战组件，它就有近战的功能，挂载了魔法组件，就可以成为法战士哥布林。这样不仅方便后续拓展，维护起来也只用在意对应组件的功能，而不用去维护所有哥布林的功能。<br>整个过程也符合开发的直觉和流程————并不是一开始就把所有的功能都写好了，而是逐步的添加，逐步的实现功能。</p><h2 id="什么是实体组件模式"><a href="#什么是实体组件模式" class="headerlink" title="什么是实体组件模式"></a>什么是实体组件模式</h2><p>偏传统模式的实体组件与ECS框架里面里面的实体组件虽然些许存在相似的地方，但却是完全不同的概念，这里不拓展展开。先说一下传统开发上的实体组件模式吧，不过要注意一下，在不同的框架中，实体组件模式的定义以及实现方式这些都是可能存在一定的差异的，皆是为了更好的实现需求，接下来要展开讲的也只是其中的一种形式，但万变不离其宗，在了解其中一种之后，再遇到也只需要类比推理即可。</p><img src="/img/entityAndComponent.png" class="post-image" /><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>实体在设计层面实体只是一个概念上的定义，是单一对象数据的载体，是一系列组件的集合。而它可以用来表示游戏中的各类物体，比如玩家或者敌人；有功能的一些道具，甚至一些比较抽象的物体。</p><p>在脚本设计上，实体可以是一个基类，它主要是用来存储对应的数据和组件的。它是应该是支持继承的，但是它的继承主要是用于拓展其数据和组件。比如，一个Entity基类，它包含一些基本和通用的信息，我们如果想要一个敌人的实体，我们就可以继承这个基类，然后添加一些敌人独有的属性和组件；如果想要一个NPC的实体，我们同样可以继承这个基类，然后添加一些NPC独有的属性和组件。<br>整个过程中，无论是敌人有自己的功能和身份标识，还是NPC有自己的特性这些，其实综合来看就是数据和组件的拓展，这也是为什么我说这种情况下继承的意义在于能够根据我们想要的情况去拓展对应的数据和组件。</p><p>这里有个要点，关于实体继承和组件怎么去搭配更好其实是有很多种方式的，这个后面会重点说一下，这里先按下不表。</p><p>那么实体是否需要处理逻辑呢？<br>在一些地方实体并不需要处理逻辑，但个人的看法是实体其实是可以处理一定程度的逻辑的。除了基本的对数据和组件的管理逻辑之外，对于一些比较通用和基本的逻辑，在我看来是可以在实体里面进行处理的，通过这些处理也可以在一定程度上提高效率。<br>但是要注意的是，实体处理逻辑的范围不应该太大，不要把它搞得太复杂，否则会影响到实体的拓展和复用，以及尽量避免把实体的功能和特定组件的逻辑耦合在一起。<br>后面要说的动作事件便是功能逻辑整合的一种方式。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>一个组件就是包含对应数据和逻辑的单一功能。<br>比如移动，HUD，巡逻这些功能都可以组件化，我们给一个实体挂载了一个这样的组件，这就意味着它具备了这个功能。也因此单个组件里面的数据和逻辑都应该服务且只服务于这个功能，应该尽量避免耦合到其他组件的功能。</p><p>组件的生命周期和更新形式应该如何试下？<br>组件的生命周期可以由实体进行传递和管理，通过实体来进行统一管理，以此来确保单个实体下对应的刷新顺序和逻辑的执行，毕竟实体也是通过上层更新进行传递，这样的从上至下可以确定一定的规范性。<br>还有一种形式是以组件为标准进行更新，在一些情况下，保证被实体使用的所有组件按照一个严格规定的顺序来更新，比一直追踪哪些实体包含那些组件来更新要更有效。就是搞一个组件系统，让组件系统将会向它所管理的所有组件实例转发更新消息，而不用考虑这些组件实例绑定的是那些实体。当然这也只是提一嘴，不过多展开。</p><p>组件是否需要处理逻辑呢？<br>一般来讲，组件是需要处理逻辑的，无论是数据的处理还是对应功能逻辑的封装这些是必定要做的，并且在需要的时候，也是可以在对应的更新方法中执行其更新逻辑的。</p><h2 id="动作事件"><a href="#动作事件" class="headerlink" title="动作事件"></a>动作事件</h2><p>动作事件层，也就是上面的Action层，这里给它的定义是：关联到多种模块的功能块。<br>实体组件模式为什么还要引入这么一个动作事件层呢？<br>因为在实际开发中，是存在需要耦合各个组件的功能从而去实现一个整体的功能的情况的，而当这些功能可能被多次复用的时候，我们可能就希望能够有这样一个“功能块”去执行这样的一个整体功能，这就是动作事件的意义所在。<br>比如，我们可能希望有一个“坐下”的动作，这个动作包含了多个组件的功能，比如移动组件，动画组件，巡路组件，这些组件的功能都需要一起执行才能实现这个动作。我们通过封装这个功能为一个“动作事件”，然后在需要的时候去执行这个动作事件，这样就能实现这个动作的执行。</p><p>它并不关心是哪个实体调用的，也不关心这个实体的任何特性，只关心这个动作的执行。这样做的好处在于给出了一个综合动作的执行位置，规范了开发细节，做到了一定层度的解耦，也方便功能的拓展和维护。</p><h2 id="实体和组件的配合形式"><a href="#实体和组件的配合形式" class="headerlink" title="实体和组件的配合形式"></a>实体和组件的配合形式</h2><ul><li>形式1：基层实体挂载通用组件，派生层实体挂载自定义特定组件</li><li>形式2：基层实体不挂载任何组件，全部根据派生层实体需求挂载自定义特定组件</li></ul><p>在形式1的情况下，基类里面可以包含通用的组件，各自派生类可以根据自己的需求挂载自定义的组件。这样做法的好处在于减少了代码的冗余度，且方便维护。<br>但是也会衍生出一些思考或者问题：</p><p>真的有所谓的通用组件吗？<br>你可能会觉得这个问题问的很抽象，但事实确实是这样，在一些情况下是不存在通用的组件的，比如物理组件也并不是所有实体都需要，健康组件也是同理。在需求如此的情况下，我们并不能说一定存在一个通用的组件，大不了存在比如HUD，游戏里面可能90%的实体都有，但是可能还是会存在10%的实体就是没有显示的需求，而如果放在了基类实体里面，那些不需要的实体就不得不挂载这个组件，并处理其逻辑，让其不影响自身的功能，这就造成了不必要的浪费。</p><p>在形式2的情况下，基类实体不挂载任何组件，全部由派生类实体挂载自定义的组件，这样做的好处可以解决上面的问题，但是稍微想一下就知道，每个类型的实体都要去挨个去处理每个组件，这其实是为了准确度牺牲了开发效率。</p><p>但是还是可以给出一些通用的建议：<br>实体的分层一定要尽可能的细致一些，特别是在决定基层的时候，如果采用了形式1，则这一点至关重要，不然可能会让后面的派生类执行过多的冗余代码，造成严重的浪费。</p><p>实体里面处理组件的逻辑应当更加少，特别是采用了形式2的情况下，如果在不同类型实体里面去处理了相同类型组件的逻辑，如果组件的内容得到了修改，有可能就会导致“牵一发而动全身”的情况，若是耦合了起来，则情况更是糟糕，这是要避免的情况。</p><h2 id="为什么不全部替换为ECS"><a href="#为什么不全部替换为ECS" class="headerlink" title="为什么不全部替换为ECS"></a>为什么不全部替换为ECS</h2><p>“现在还没有用ECS的都是对技术不上进的”，有幸在某个地方听到过这样一句话。<br>这句话听着很抽象，毕竟还是要根据是根据实际情况实际分析的。</p><p>传统的实体组件模式更符合OOP的思想，使用起来更加灵活，容易上手且开发便捷，它更加适合中小型项目的开发。相反，ECS的对数据要求进行严格的规划，模块之间耦合更低，能应对处理大量实体的情景，但随之而来的是架构的复杂性提升。拿ECS去做一些体量和功能都较小的项目，其对大场景的优化设计好拓展性反而成为了最冗余的部分。</p><p>还是那句话——没有最好的，只有最适合的。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://gameplaykit-programming-guide-chinese.readme.io/docs/%E5%AE%9E%E4%BD%93%E4%B8%8E%E7%BB%84%E4%BB%B6">实体与组件</a></li><li><a href="https://zhuanlan.zhihu.com/p/698371236">游戏开发之组件模式</a></li><li><a href="https://zhuanlan.zhihu.com/p/464586801">从游戏设计角度看基于组件的游戏开发方式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Entity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实体 </tag>
            
            <tag> 组件 </tag>
            
            <tag> 动作事件 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个较通用的UI框架</title>
      <link href="/2025/04/06/uiframework/"/>
      <url>/2025/04/06/uiframework/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文会浅谈UI框架的设计和关注要点，如果对UGUI基础理论和性能优化感兴趣，可以参考之前的文章，如果想要了解更多可以查看本文下面的推荐文章。</p><h2 id="为什么需要UI框架，其设计思想是什么"><a href="#为什么需要UI框架，其设计思想是什么" class="headerlink" title="为什么需要UI框架，其设计思想是什么"></a>为什么需要UI框架，其设计思想是什么</h2><p>试想一下如果没有一个统一的UI框架，所有的业务程序员会如何进行UI的开发——一个人一个策略，组件各种方式搜集，写法千差万别，轮子任意造，维护成本巨大，整体可读性极差，也就是所谓的“混乱”。</p><p>我曾经问过大佬们为什么需要设计框架，收到了这样一个答案——解耦。让每个模块的职责单一化，让各个模块整合起来能实现我们想要的功能的便是框架。而UI框架里面的一个解耦要点就是数据和逻辑的分离和组合。</p><p>总结一下便是说通过约束性设计和标准化的管理来防止随着业务需求增加的同时，代码的混乱度增加，以及随之而来的性能问题，巨大的维护成本。</p><p>我把这个问题抛给DeepSeek，其回答有一句我认为是比较精辟的：<br>框架的本质是<strong>通过约束创造自由</strong>——看似限制了编码方式，实则通过规范化设计让开发者能更专注于业务开发和创新。如同交通规则的存在不是为了限制驾驶，而是为了让所有车辆能高效安全地到达目的地。</p><h2 id="如何设计一个较通用的UI框架"><a href="#如何设计一个较通用的UI框架" class="headerlink" title="如何设计一个较通用的UI框架"></a>如何设计一个较通用的UI框架</h2><img src="/img/uiframe_points.png" class="post-image" /><p>这里要说一下，在本人目前接触到的各个UI框架中，有的确实能说设计的不错，功能很强，但即使如此，也不能绝对的说某一个就是最好的。因为根据不同的项目需求，不同的业务场景，不同的团队情况，都有不同的UI框架的需求。有的框架可能在某个项目中有着巨大的作用，但可能换一个地方，其各种功能根本用不上，其设计便存在了巨大的冗余之处。<br>但即使如此，我们还是可以总结经验，提炼出一个较为通用的UI框架设计思路。接下来会就各个功能点来进行阐述。</p><h2 id="可供参考结构"><a href="#可供参考结构" class="headerlink" title="可供参考结构"></a>可供参考结构</h2><img src="/img/uiframe_structure.png" class="post-image" /><img src="/img/uiframe_process1.png" class="post-image" /><img src="/img/uiframe_process2.png" class="post-image" /><h2 id="组件绑定"><a href="#组件绑定" class="headerlink" title="组件绑定"></a>组件绑定</h2><p>页面逻辑执行脚本获取对应的依赖UI组件的方式有很多种，最简单的直接拖动当然是可以的，不过成熟的框架往往都会提供更加便捷的组件绑定方式，而如果是使用Lua进行开发的话则更加重要。<br>鄙人有幸见识过通过改写LuaBehaviour的内部逻辑，支持拖动脚本组件到对应View层的变量上的做法，这种做法不能说有点问题吧，只能说极其糟糕。它利用的是Unity的序列化在编辑器的可视化交互，这样做貌似直观，清晰，但随之而来的问题也比较严重。<br>那么一个好的组件绑定工具应该注重哪些点呢</p><ul><li><strong>规划化命名。</strong> 工具绑定命名的规范化也就是组件命名的规范化，这是“强制性”的让使用者按照固定的规范进行命名的，才成跑通自己功能的形式。 如果对命名规范没有要求，各种五花八门的命名和随意拖拽，就会导致无法快速查找和定位。</li><li><strong>使用便捷。</strong> 比较理想的形式是当我们按照规范进行命名后，就可以一件实现绑定了。</li><li><strong>维护成本较低</strong> 需求变动时带来大量UI改动的时候，只需要修改对应的命名，再正常跑一遍流程，就可以很快完成修正和绑定。</li><li><strong>对于Item的组件绑定的支持。</strong> 在书写工具的时候，不应当只考虑一个页面的绑定，对于列表页，或者复杂的列表页，还需要考虑如何如何绑定Item的。</li></ul><p>而如果是只采用上面的“拖动”方式，业务内容一多，上面的问题想必</p><h2 id="层级划分问题"><a href="#层级划分问题" class="headerlink" title="层级划分问题"></a>层级划分问题</h2><img src="/img/uiframe_layer.png" class="post-image" /><p>做好层级划分是为了处理多种功能的UI页面，这些页面有着不同的特性，比如有的页面需要全屏显示，有的页面需要弹出，有的页面需要遮挡住其他页面等等。我们通过给它们分类放在不同的层级，让它们按照我们指定的规则去进行显示，保证显示效果的同时，也能根据这个去规则化特效的层级问题，而如果是特效的话，我们一般会还会要求特效Shader支持stencil和clipRect。</p><p>对于2D页面和3D场景混合的页面，我们可以把3D场景渲染到一个RawImage上面，然后进行显示，这也是UIRoot里面SceneImage的作用。这样不用考虑3D模型和UI元素深度的冲突以及层级的问题，也能更好地调整效果。</p><p>本人曾经也思考过一个问题：First和Second层逻辑同时存在是否会显得冗余？在我看来并不会，通过规则化First层和Second层的具体逻辑可以使得层级分明逻辑清晰，比如我们可以规定全屏且参与栈打开的页面都必须是First层级的，其他的Pop页面都是Second的，我相信也是没有什么问题的；但一定得这么做吗？这就不一定了，毕竟可以还是可以通过其他参数或者情况的判定而实现。可能每个项目都会有不同的情况，诸如此类根据具体的情况和确切的需求来定即可。</p><h2 id="通用页面底板的设计"><a href="#通用页面底板的设计" class="headerlink" title="通用页面底板的设计"></a>通用页面底板的设计</h2><p>在游戏设计的初始阶段，当美术统一化规范设计后，就可以设计出对应的UI通用底板了，从而减少UI的冗余拼接并确定同一的显示效果。在UI框架上体现出的便是相同类型的页面具备相同的底板，底板自带部分逻辑且支持通用。<br>这样做可以减少代码重复度，提高开发效率。</p><h2 id="通用tips弹窗"><a href="#通用tips弹窗" class="headerlink" title="通用tips弹窗"></a>通用tips弹窗</h2><p>通用的各种类型的弹窗也是游戏里面往往会用到的，设计好和实现好这一部分能剩下不少事情。一般我们的弹窗可能都会是一时间只能打开一个，但是游戏游戏逻辑是需要多弹窗同时存在的且下一弹窗可能通过上一弹窗进行打开，然后按照顺序关闭，这些其实也都并不复杂，根据需求来做即可。</p><p>至于这些弹窗的管理，不同于普通的页面。举个例子，我们可以通过一个单独的列表来管理当前的弹窗——MultiWindows。这些弹窗不会参与其他页面的任何打开逻辑，反之亦然。它们有着自己单独的逻辑。</p><h2 id="打开UI卡顿和页面数据同步问题"><a href="#打开UI卡顿和页面数据同步问题" class="headerlink" title="打开UI卡顿和页面数据同步问题"></a>打开UI卡顿和页面数据同步问题</h2><p>首先要确定卡顿的形式，资源加载消耗或者页面Rebuild消耗，这些可以参考之前的文章。这里说一下另一种数据异步的问题。</p><p>当一个页面需要服务器实时去同步数据的时候，而页面则是需要及时打开的，这就会面对一个问题——页面打开了，但是服务器的回调还没发过来，也就是说没拿到数据。</p><p>针对这种问题，可能会考虑到，比如在游戏一开始的时候就把我们想要的数据从服务器那边申请下来，并进行缓存，这样我们后面要用的时候不就可以直接用了吗，就可以完美解决这样的问题了。但是如果这样的话，数据一多或者需要的地方多了，在登录的时候就会请求众多且可能冗余的数据。</p><p>还有一种方式就是先做默认的表现形式，就是页面打开的时候先检查数据，如果没有数据的话，就赋予默认的数据，让页面按照默认的形式显示获取加载中之类的表现形式，然后等数据到了的时候再去刷新一遍页面即可。</p><h2 id="页面存储结构管理"><a href="#页面存储结构管理" class="headerlink" title="页面存储结构管理"></a>页面存储结构管理</h2><p>我们在存储各个页面的数据的时候，往往需要多个容器存不同类型的数据。<br>比如我们可以有四个容器进行管理，</p><ul><li>PopWindows，用来状态我们所有打开着的UIStcheme。</li><li>PopStack，用栈的形式来管理普通页面打开的顺序，并且以此为基准进行同一打层级中每个UI的层级排序。</li><li>FullScreenWindows，用来存储全屏显示的UI。这只用于全屏的页面，同样是栈的形式来实现，实现全屏页面的栈打开和关闭。</li><li>MultiWindows，用来存储弹窗页面的列表。区别于上面的任何一个逻辑，且支持多个同时存在。</li></ul><p>通过这样各司其职的管理，可以有效地避免数据混乱，提高代码的可维护性。</p><h2 id="逻辑和数据解耦"><a href="#逻辑和数据解耦" class="headerlink" title="逻辑和数据解耦"></a>逻辑和数据解耦</h2><p>要实现这一点也与框架的选择有关系，比如MVC，MVVM这些其实都是为了解耦数据和逻辑。<br>那MVC举例，可以从三个部分理解，Model，View，Controller。</p><ul><li>Model：只负责存储数据。也就是单存的存储，它于任何数据处理逻辑以及显示效果没有任何一点关系。</li><li>View：只负责显示效果。通过将逻辑处理完的数据显示出来。</li><li>Controller：负责处理逻辑。它与任何数据的存储以及页面显示没有任何关系。</li></ul><p>这其实就很可以提现上面所说的框架的思想————解耦。让每个模块的职责单一化，让各个模块整合起来能实现我们想要的功能。</p><p>还有一种实现形式：<br>有的项目会把主要的数据存储于其他地方（比如管理器），任何UI的数据都看做“临时的”，这样M层则不一定需要脚本化。如果采用这种形式，V层也没有脚本化的绝对的必要性，组件的绑定和获取以及页面的控制都可以通过一些工具进行绑定，C层可以直接使用，也就不用通过V层获取组件。它其实采取的也是MVC的思想，但使用这种形式的人可能是觉得原封不动的MVC有很多冗余的地方，写起来不方便或者看起来不是很简洁。</p><p>依我之见的话，这种形式它其实考虑就是两个方面：</p><ul><li>不要V层脚本。V层里面如果不涉及到组件绑定的话，V层的控制是最少的，C层能直接拿到组件，还不如直接写在C层，减少跳转跳转，便捷开发，这种层度的耦合不会影响开发，反而更加直观；</li><li>选择性不要M层脚本。坚持如果UI需要数据可以从它处取，关于UI自身的数据往往具有很强的“临时性”，因此没有必要专门整个M层，通过C层区域化定义，关闭时置空，这种层度的耦合也不会影响开发，反而更加直观。</li></ul><p>如果按照这个角度来考虑的话，个人认为根据数据情况来选择其实是可以的，传统的MVC在一些项目中很多情况的书写方式确实存在冗余时候，选择性的使用这种方式可能更加便捷好直观，重要的是核心的数据和逻辑还是分离开的，只要不出现把其他的数据存在对应UI里面（无论任何一个层）的情况，适当的变通也是可以的。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>动画的话，目前接触到的使用最多的还是DOTween，它可以让我们快速实现一些动画效果，使用起来方便，简单。<br>置于是使用其挂载式的组件脚本，还是通过代码去动态控制，这边一般会选择后者。因为前者十分起来对应的预制体节点，伴随着UI页面的多次迭代，这种维护和修改会比后者麻烦一些。而如果使用后者做动画的话，则是需要考虑tween的管理，不要“到处乱拉”。</p><h2 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h2><p>适配要注意的问题的话，比较常见的有：</p><ul><li>适配刘海屏。这方面Unity官方貌似也是有插件的，可以快速调整。而如果是手动设置的话，就需要考虑多个机型的安全区进行多次测试进行调试。</li><li>适配不同分辨率屏幕。这个的话，根据不同项目可能有不同的表现形式，有的美术可能希望要原封不动的保留其本身的背景比例，空余的部分去加黑边。有的则可能会从出图上去出更大的图，然后去解决可能的适配填充拉伸问题。</li></ul><p>当然，CanvasScaler的相关属性和Canvas的模式这些都需要考虑，不过只要整体方案确定了，这方面还是比较好调节的。<br>这方面感兴趣的可以参考Unity的官方文档和下面的文章链接。</p><h2 id="页面之间的通信和嵌套"><a href="#页面之间的通信和嵌套" class="headerlink" title="页面之间的通信和嵌套"></a>页面之间的通信和嵌套</h2><p>页面之间的通信主要有两种形式————消息事件和子页面传递。<br>前者不多赘述，这里说一下后者。<br>一个页面可能包含多个子页面，甚至它本身可能就是由多个子页面组成的，这种子页面我们称之为SubView或者说Widget。</p><p>为什么会有子页面？</p><ul><li>分担页面逻辑。当一个页面过大，包含多重页面和多种逻辑的时候，如果就这样只放在一个页面里面的话，当页面打开的时候不仅UI预制体加载时间会过长，而且页面脚本逻辑也会因为冗长的逻辑代码导致可读性差，维护成本也随之上升。如果使用子页面进行分担的话，每个子页面模块就可以专注对应的功能，每个部分的功能也都清晰可见。</li><li>选择页面逻辑。当一个页面可以存在多个子页面，且这些子页面随着不同的情况，有着不同的表现形式。比如一个主菜单页面可能由多个子页面组成，当跳转不同的场景的时候可能需要显示不同的内容，也就是说不同的情况，可能显示多种搭配。这种情况的话，我们就可以选择性生成并且很好地适应需求变化。而不是杂糅在一个页面里面去处理。</li></ul><p>嵌套之间的数据通过管理进行传递，往往主页面是包含子页面的脚本数据的，可以通过这种形式传递数据给子页面；而子页面通过缓存主页面脚本，也可以把想要的内容回传给主页面。即使这样的嵌套有多层，也可以通过这种形式传递实现功能。<br>而实际开发中，我们一般并不希望一个页面的垂直上面嵌套超过三层。因为过多的嵌套会也回导致代码的可读性差，维护成本也会随之上升。</p><p>不过有一个值得注意的点是 分子页面逻辑是为了主要处理页面的繁多，还是为了处理众多的逻辑决定了子页面的形式，也决定了数据的管理形式。<br>比如说，一个页面如果需要包含不同时出现的子页面，且页面复杂的时候，我们可能希望每个子页面都是一个单独的预制体和对应的脚本逻辑，其当然可以有父页面传递的通用数据，不过更多的还是管理自己的页面和自己的数据；<br>而一个页面如果不需要同时出现，页面也并不算复杂，但是每个部分的逻辑却相当多的时候，我们可能更倾向于针对于每个部分写功能脚本，然后传递通用model数据，就不用把页面单独拆出来。</p><p>此外对于子页面的生命周期管理，我们也需要注意，比如说子页面的生命周期是由父页面控制还是由子页面控制，这也会影响到子页面的设计。<br>所以到底是父页面统一管理还是子页面自行控制这也是个重点。<br>如果使用前者，确保生命周期同步，严格按照给定顺序执行的同时，经过统一处理可以有效防止内存泄露，但这种形式也增加了一部分的耦合。<br>后者这种松耦合的形式当然可以增加灵活性，但业务开发中也可能因此出现规范不统一的情况。<br>本人基本使用过的是前者，知道前者的好处，主要是方便管理和控制。</p><h2 id="其他可供参考文章"><a href="#其他可供参考文章" class="headerlink" title="其他可供参考文章"></a>其他可供参考文章</h2><ul><li><a href="https://www.lfzxb.top/personal-ui-framework-consider/">烟雨的个人思考</a></li><li><a href="https://zhuanlan.zhihu.com/p/667966938">Unity的UI系统框架</a></li><li><a href="https://www.drflower.top/posts/16213a73/">GF的页面解析</a></li><li><a href="https://www.mscworld.top/2024/12/22/ugui/">UGUI 基础理论和性能优化</a></li><li><a href="https://www.rtcdeveloper.cn/cn/community/blog/21135">Unity 开源项目推荐 UI 篇</a></li><li><a href="https://docs.unity3d.com/cn/2021.1/Manual/HOWTO-UIMultiResolution.html">Unity官方手册——设计用于多种分辨率的UI</a></li><li><a href="https://cloud.tencent.com/developer/article/1637553">Unity3D-关于项目的屏幕适配</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
            <tag> UI </tag>
            
            <tag> 优化 </tag>
            
            <tag> UI框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xLua知识点总结</title>
      <link href="/2025/01/22/xlua/"/>
      <url>/2025/01/22/xlua/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇整理了xLua的一些重要知识点，画了思维导图，方便记忆和回顾。<br><img src="/img/xLua_Mind.png" class="post-image" /></p><h2 id="代码热更新"><a href="#代码热更新" class="headerlink" title="代码热更新"></a>代码热更新</h2><p>热更新是指在不需要重新编译打包游戏的情况下，在线更新游戏中的一些非核心代码和资源，比如活动运营和打补丁。代码热更新实际上也是把代码当成资源的一种热更新，代码热更主要包括Lua热更新、ILRuntime热更新和C#直接反射热更新等。目前大多采用更成熟的、没有平台限制的Lua热更新方案。而近年来，ILRuntime 和 HybridCLR 等基于 C# 的热更新方案逐渐流行。这些方案支持直接使用 C# 进行热更新，避免了 Lua 和 C# 混合开发的复杂性，同时提供了更好的性能和开发体验。<br>另外，因为本人实际开发中，热补丁的应用极少，且热补丁的使用存在相当的缺陷，因此本文并不会提及此模块。</p><h3 id="为什么C-不能热更"><a href="#为什么C-不能热更" class="headerlink" title="为什么C#不能热更"></a>为什么C#不能热更</h3><p>C#是编译型语言，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。<br>C#的编译流程：写好的代码-&gt;编译成.dll扩展程序（UnityEditor完成）-&gt;运行于Unity</p><p>所以直接使用C#进行热更新显然是不可行的，但是也不是说一点办法也没有。在安卓上可以通过C#的语言特性-反射机制实现动态代码加载从而实现热更新。但苹果对反射机制有限制，不能实现这样的热更。为了安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。</p><h3 id="使用Lua进行热更新方案"><a href="#使用Lua进行热更新方案" class="headerlink" title="使用Lua进行热更新方案"></a>使用Lua进行热更新方案</h3><p>Lua 则是解释型语言，并不需要事先编译成块，而是运行时动态解释执行的。这样Lua就和普通的游戏资源如图片，文本没有区别，因此可以在运行时直接从WEB服务器上下载到持久化目录并被其它Lua文件调用。<br>Lua热更新解决方案是通过一个Lua热更新插件（如uLua、sLua、toLua、xLua等）来提供一个Lua的运行环境以及和C#进行交互。而xLua是腾讯开源的热更新插件，有大厂背书和专职人员维护，插件的稳定性和可持续性较强。</p><h3 id="xLua的特性"><a href="#xLua的特性" class="headerlink" title="xLua的特性"></a>xLua的特性</h3><ul><li>支持各版本的Untiy</li><li>支持多种平台</li><li>互访技术。生成适配代码，反射。</li><li>易用性。解压即可用，不需要生成代码，更加简单的无GC API等。</li><li>性能优化。Lazyload技术，避免用不上的类型的开销等。</li></ul><h2 id="CSharp和Lua侧的交互"><a href="#CSharp和Lua侧的交互" class="headerlink" title="CSharp和Lua侧的交互"></a>CSharp和Lua侧的交互</h2><p>这里重点说一下Lua调用C#层面。</p><h3 id="LuaCallCSharp"><a href="#LuaCallCSharp" class="headerlink" title="LuaCallCSharp"></a>LuaCallCSharp</h3><h4 id="传递C-对象到Lua"><a href="#传递C-对象到Lua" class="headerlink" title="传递C#对象到Lua"></a>传递C#对象到Lua</h4><img src="/img/xLua_LuaCallCSharp.jpg" class="post-image" /><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>要说性能优化，首先便是要会导致性能问题的地方。这里可以两个方面来说—————调用方面和传参方面。</p><h5 id="性能消耗"><a href="#性能消耗" class="headerlink" title="性能消耗"></a>性能消耗</h5><p><span style="background-color:rgb(100,200,200,0.5)">调用方面</span><br>通过上面的流程，我们其实可以看到调用的过程中，做了很多包括但不限于取值，入栈，缓存，类型转换等操作，这本身是一个很“昂贵”的操作，而这种操作如果如果过于频繁是会造成相当多的性能消耗。<br>好在我们知道Lua和C#之间的引用是通过索引来进行关联的，只要对象没有被gc，其实也就是查查缓存的事情，但如果已经释放掉了，便是要重新走一遍调用的流程。因此对应临时且多次调用而导致反复分配和gc的情况，便会出现性能问题。<br>比如：gameobj.transform就是一个巨大的陷阱，因为.transform只是临时返回一下，但是你后面根本没引用，又会很快被lua释放掉，导致你后面每次.transform一次，都可能意味着一次分配和gc。</p><p><span style="background-color:rgb(100,200,200,0.5)">传参方面</span><br>在lua和c#间传递unity独有的值类型（比如Vector3&#x2F;Quaternion等）更加昂贵,因为这涉及到Lua和C#类型的类型转换，多个参数多次的入栈出栈，内存分配等操作。</p><p>虽然我们说的是lua和c#的传参，但是从传参这个角度讲，lua和c#中间其实还夹着一层c，lua、c、c#由于在很多数据类型的表示以及内存分配策略都不同，因此这些数据在三者间传递，往往需要进行转换（术语parameter mashalling），这个转换消耗根据不同的类型会有很大的不同。<br>例如c#将Vector3传给lua，整个流程如下：</p><ol><li>c#中拿到Vector3的x,y,z三个值</li><li>push这3个float给lua栈</li><li>然后构造一个表，将表的x,y,z赋值</li><li>将这个表push到返回值里<br>一个简单的传参就要完成3次push参数、表内存分配、3次表插入，性能可想而知。</li></ol><p>整理一下：</p><ul><li>严重类： Vector3&#x2F;Quaternion等unity值类型，数组</li><li>次严重类：bool string 各种object</li><li>建议传递：int float double</li></ul><ol><li>bool string类型，涉及到c和c#交互的性能消耗，这两者在c和c#中的内容表示不一样，意味着从c传递到c#的时候需要进行类型转换，降低性能。同时string还要考虑内存的重新分配（将string的内存复制到托管堆，以及utf8和utf16的互相转换）。</li><li>V3&#x2F;Quaternion，数组甚至更加严重。先说数组，因为lua中只有一个table，和c#是完完全全的两码事，因此这两者的转换只能逐个复制。 而如果成员涉及到的object&#x2F;string等相关类型，更是要逐个转换。</li><li>int float double 类型是推荐的，因为不涉及到过分的类型转换。</li></ol><h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h5><p><span style="background-color:rgb(100,200,200,0.5)">调用方面：</span> 针对lua里面获取到的c#里面的object为例， 我们不再使用 “.” 去直接点出它的属性，而是通过访问静态方法执行此object的功能。当然，这需要我们对这个object书写静态拓展方法（之所以说拓展方法，毕竟我们引用的基本上是unity里面go的组件），或者通过统一静态类来管理这种object。 这里选这是前者，我们封装对于组件的拓展方法，然后把self和此操作需要的参数传过去，在此静态方法中执行我们想要的操作。如果当前需要更多的操作，那也只需要的写更多的拓展方法即可。<br>通过这种形式来减少对于go的组件的引用，特别是.transform这种临时引用。</p><p><span style="background-color:rgb(100,200,200,0.5)">传参方面：</span> 减少Unity独有值类型的等相关的传参。建立在上面拓展方法的基础上，我们的实现方式就是写重载的拓展方法，允许多样的传参或者统一go上面组件获取的调用去实现功能。</p><h5 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h5><p>比如在lua侧想获取一个GO的transform，我们一般会直接调用 obj.transform；再比如我们想要获取游戏中的一个GO，然后控制其显示和隐藏，就可以使用SetActive这个接口。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> GameObject = CS.UnityEngine.GameObject</span><br><span class="line"></span><br><span class="line">//首先，我们先获取一个测试Obj和它的组件和子物体</span><br><span class="line"><span class="keyword">local</span> obj = GameObject(<span class="string">&quot;Test&quot;</span>)   </span><br><span class="line"><span class="keyword">local</span> img_obj = obj:GetComponet(typeof(CS.UnityEngine.UI.Image))</span><br><span class="line">//获取子物体一般是通过.transfrom:Find的方式获取</span><br><span class="line"><span class="keyword">local</span> rect_objChild = obj.transform:Find(<span class="string">&quot;objChild&quot;</span>):GetComponent(typeof(CS.UnityEngine.RectTransform))</span><br><span class="line"></span><br><span class="line">//然后我们设置它的现隐</span><br><span class="line">obj.gameObject:SetActive(<span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line">//通过图片的组件获取便是</span><br><span class="line">img_obj.gameObject:SetActive(<span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>而如果使用拓展方法的话，就会使用这种写法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">LuaCallCSharp</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UnityObjectExtends</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transform <span class="title">GetTransform</span>(<span class="params"><span class="keyword">this</span> Component target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target.transform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transform <span class="title">GetTransform</span>(<span class="params"><span class="keyword">this</span> GameObject target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target.transform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transform <span class="title">GetTransform</span>(<span class="params"><span class="keyword">this</span> Transform target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------分割线-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于控制现隐的操作，我们可以在此进行拓展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//value，1表示开启，0表示关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetActiveE</span>(<span class="params"><span class="keyword">this</span> Component target, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SetActiveE(target.gameObject, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetActiveE</span>(<span class="params"><span class="keyword">this</span> GameObject target, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bool</span> flag = <span class="number">1</span> == <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">if</span> (target.activeSelf == !flag)</span><br><span class="line">        &#123;</span><br><span class="line">            target.SetActive(flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetActiveE</span>(<span class="params"><span class="keyword">this</span> Transform target, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bool</span> flag = <span class="number">1</span> == <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">if</span> (target.gameObject.activeSelf == !flag)</span><br><span class="line">        &#123;</span><br><span class="line">            target.gameObject.SetActive(flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的操作也就变成了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> GameObject = CS.UnityEngine.GameObject</span><br><span class="line"></span><br><span class="line">//首先，我们先获取一个测试Obj和它的组件和子物体</span><br><span class="line"><span class="keyword">local</span> obj = GameObject(<span class="string">&quot;Test&quot;</span>)   </span><br><span class="line"><span class="keyword">local</span> img_obj = obj:GetComponet(typeof(CS.UnityEngine.UI.Image))</span><br><span class="line">//获取子物体的方式也变成了</span><br><span class="line"><span class="keyword">local</span> rect_objChild = obj:GetTransform():Find(<span class="string">&quot;objChild&quot;</span>):GetComponent(typeof(CS.UnityEngine.RectTransform))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//控制现隐</span><br><span class="line">obj:SetActiveE(<span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line">//通过组件来控制</span><br><span class="line">img_obj:SetActiveE(<span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>业务开发中，如果要求采用这种方式进行开发，往往会搭配列一个黑名单，禁止直接调用。</p><p>比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">BlackList</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;<span class="built_in">string</span>&gt;&gt; blackList = <span class="keyword">new</span> List&lt;List&lt;<span class="built_in">string</span>&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Componet</span></span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Component&quot;</span>, <span class="string">&quot;transform&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Component&quot;</span>, <span class="string">&quot;gameObject&quot;</span>&#125;,</span><br><span class="line">        <span class="comment">//方法</span></span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Component&quot;</span>, <span class="string">&quot;GetComponent&quot;</span>,<span class="string">&quot;System.Type&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Component&quot;</span>, <span class="string">&quot;GetComponent&quot;</span>,<span class="string">&quot;System.String&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transform</span></span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;childCount&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;localPosition&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;localRotation&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;parent&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;position&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;rotation&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法</span></span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;Find&quot;</span>, <span class="string">&quot;System.String&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;FindChild&quot;</span>,<span class="string">&quot;System.String&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;GetChild&quot;</span>,<span class="string">&quot;System.Int32&quot;</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123; <span class="string">&quot;UnityEngine.Transform&quot;</span>, <span class="string">&quot;GetChildCount&quot;</span>&#125;,</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>blackList的目的是为了防止程序员自己又调用了内置接口，比如来新人或者有些人写着写着忘记了 因为这些函数已经封装了正确的调用函数 所以安全起见全部不容许导出xlua。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://cloud.tencent.com/developer/article/2239496">Untiy热更新技术基本理念</a></li><li><a href="https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/XLua%E6%95%99%E7%A8%8B.md">xLua官方教程</a></li><li><a href="https://www.cnblogs.com/iwiniwin/p/15307368.html">深入xLua实现原理之Lua如何调用C#</a></li><li><a href="https://www.playcreator.cn/archives/unity/4354/XLua">xLua热更方案深度解析_标记和交互的使用说明</a></li><li><a href="https://blog.csdn.net/wotingdaonile/article/details/126159612">Lua与c#交互篇性能优化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
            <tag> xLua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua重要知识点总结</title>
      <link href="/2025/01/12/lua/"/>
      <url>/2025/01/12/lua/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章主讲三个方面：Lua的性质，Lua的基础理论和重要知识点。尝试言简意赅的呈现各个模块的知识点，并且把一些平时开发可能不会注意到的地方呈现出来。</p><h2 id="Lua的性质"><a href="#Lua的性质" class="headerlink" title="Lua的性质"></a>Lua的性质</h2><h3 id="Lua的设计目的"><a href="#Lua的设计目的" class="headerlink" title="Lua的设计目的"></a>Lua的设计目的</h3><p>Lua是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放，从一开始就把轻量化，可移植性，可嵌入型，可扩展性等作为自己的设计目标，作为胶水语言来辅助像是C，C++这样的主角来更好地完成工作。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="轻量型"><a href="#轻量型" class="headerlink" title="轻量型"></a>轻量型</h4><p>非常小的尺寸，5.1版本的压缩包仅有208KB，解压后也不过是835KB，Lua解释器只有17000多行的C代码，编译后二级制库文件仅有143KB。</p><h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>使用clean C 编写的解释器，可以在Mac，Unix，Windows等多个平台轻松编译通过。</p><h4 id="可嵌入型"><a href="#可嵌入型" class="headerlink" title="可嵌入型"></a>可嵌入型</h4><p>Lua提供非常丰富的API，可以提供宿主程序与Lua脚本之间进行通信和数据交换。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>语法简单，容易上手，学习成本低。在有其他语言基础而完全未接触过Lua的情况下，能在3天内快速上手并投入业务开发。</li><li>轻量，占用小。</li></ul><h3 id="Lua与游戏开发"><a href="#Lua与游戏开发" class="headerlink" title="Lua与游戏开发"></a>Lua与游戏开发</h3><p>对从事游戏开发行业中的人来说，Lua语言可能并不陌生。因为它满足了占中国游戏市场半壁江山的手游的热更需求，且在经历过国内网易，西山居，腾讯等行业头部的公司的使用，形成多个成熟的Lua热更方案后，Lua作为热更新脚本语言已经成为一时的主流。<br>虽然今年随着更多热更方案的兴起，部分人认为Lua相关的热更方案已经过时了，但在一些老的项目以及游戏框架万年不变的换皮公司中，Lua仍旧是不二之选。</p><h2 id="Lua的基础理论"><a href="#Lua的基础理论" class="headerlink" title="Lua的基础理论"></a>Lua的基础理论</h2><p>这里不会从数据类型开始一一介绍，而是会着重讲解一些比较重要以及可能会混淆的知识点。</p><h3 id="pairs和ipairs"><a href="#pairs和ipairs" class="headerlink" title="pairs和ipairs"></a>pairs和ipairs</h3><p>简单直接的说两者在遍历上的差距在于</p><ol><li>pairs的遍历顺序是随机的，但是一定会遍历整个表；ipairs遍历是从索引1开头按顺序遍历的，中途索引不能断开，否则终止遍历；</li><li>pairs是先按照索引值遍历，然后按照键值对。</li></ol><p>接下来通过一个例子来说明差异，这个例子包含3个样例。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> orderTable = &#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> keyTable = &#123;</span><br><span class="line">    [<span class="number">0</span>] = <span class="number">0</span>,</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mixTable = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    [<span class="number">4</span>] = <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    [<span class="number">6</span>] = <span class="number">6</span>,</span><br><span class="line">    <span class="literal">nil</span>,</span><br><span class="line">    [<span class="number">8</span>] = <span class="number">8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printTable</span><span class="params">(t,prefix)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----------&quot;</span>.. prefix.. <span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;count :&quot;</span>.. #t)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;pairs:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ipairs:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">printTable(orderTable,<span class="string">&quot;orderTable&quot;</span>)</span><br><span class="line">printTable(keyTable,<span class="string">&quot;keyTable&quot;</span>)</span><br><span class="line">printTable(mixTable,<span class="string">&quot;mixTable&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其打印结果如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">----------orderTable-----------</span></span><br><span class="line">count :<span class="number">3</span></span><br><span class="line"><span class="built_in">pairs</span>:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">ipairs</span>:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">----------keyTable-----------</span></span><br><span class="line">count :<span class="number">1</span></span><br><span class="line"><span class="built_in">pairs</span>:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">ipairs</span>:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">----------mixTable-----------</span></span><br><span class="line">count :<span class="number">2</span></span><br><span class="line"><span class="built_in">pairs</span>:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="built_in">ipairs</span>:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先看第一个样例，orderTable。<br>pairs和ipars遍历结果一致，都是1，2，3。<br>这是因为ipairs满足从索引1开始按顺序遍历的条件，而无论跑多少次，你都可以发现两者的结果永远一致。这时候你可能会有疑问，上面不是说pairs的遍历结果是随机的吗？这个我们放在mixTable的时候一起说。</p><p>接下来看第二个样例，keyTable。<br>pairs遍历结果是0,1,3 ，而ipairs遍历结果是1。<br>ipairs遍历结果因为需要从1开始且出现了索引不连续，因此断开了，只打印了1。</p><p>最后看第三个样例，mixTable。<br>pairs遍历结果是3，hello world，8，4，6，而ipairs遍历结果只有一个3。<br>这里你可能会局的奇怪，按照上面的理论，总成员明明有8个，而pairs出去nil却只打印了5个成员，而ipars按照顺序明明看起来有3个，却只打印出了一个3,。</p><p>结合上面的的共同点，可以发现 mixTable前面的两个元素：[1] &#x3D; 1 和 [2] &#x3D; 2 通过这两种方式都没有被打印出来。这又是为什么呢？</p><p>我们先拆分一下mixTable里面的组成：<br>显式键值对形式部分： {<br>    [1] &#x3D; 1,<br>    [2] &#x3D; 2,<br>    [4] &#x3D; 4,<br>    [6] &#x3D; 6,<br>    [8] &#x3D; 8,<br>}<br>隐式形式部分：{<br>    3,<br>    “hello world”,<br>    nil,<br>}</p><p>再把后者中的元素替换前者中对应冲突的键值对<br>首先，后者中的元素形式可以表现为：<br>{<br>    [1] &#x3D; 3,<br>    [2] &#x3D; “hello world”,<br>    [3] &#x3D; nil<br>}</p><p>此时可以明显发现冲突，前者中已有的键值对 [1] 和 [2] 与数组中的冲突了，因此需要进行重新匹配，把前者中的替换为后者中的，最终表的形式可以表示为：<br>{<br>    [1] &#x3D; 3,<br>    [2] &#x3D; “hello world”,<br>    [3] &#x3D; nil,<br>    [4] &#x3D; 4,<br>    [6] &#x3D; 6,<br>    [8] &#x3D; 8,<br>}<br>这才是真正遍历的表。再通过初步的理论，推导出结果并对比遍历的结果，便不难理解了。</p><p>最后再来说一下pairs的“随机性”，出现这个问题的原因是因为对于lua中的表来说，其遍历标的次序取决于key的hash值，而lua中很多数据类型的哈希值都是随机的。</p><p>如果有需要可以重写pairs迭代器，实现顺序遍历。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairsByKeys</span><span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> sorted = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        sorted[#sorted + <span class="number">1</span>] = k</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">sort</span>(sorted)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">local</span> v = t[sorted[i]]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> sorted[i], t[sorted[i]]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> pairsByKeys(mixTable) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line">hello world</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意这里本质上是根据key值进行排序，并不是按照表中定义的顺序，无法处理key值无法对比排序的情况，更无法解决冲突的问题，且效率较低。</p><h3 id="loadfile-dofile-require"><a href="#loadfile-dofile-require" class="headerlink" title="loadfile,dofile,require"></a>loadfile,dofile,require</h3><ul><li>loadfile ——只编译，不运行。loadfile只会加载对应路径的文件，编译其代码，但是不会运行文件里的代码。<br>它会返回一个函数，可以接收后，通过调用并执行里面的代码。</li><li>dofile ——编译并运行。dofile会加载对应路径的文件，编译其代码，并运行文件里的代码。</li><li>require ——加载并运行，之后进行缓存。缓存之后再次require同一文件不会再执行。</li></ul><h3 id="rawset和rawget"><a href="#rawset和rawget" class="headerlink" title="rawset和rawget"></a>rawset和rawget</h3><p>顾名思义，raw表示原始的，则rawset和rawget表示对“原始的”表进行直接的赋值&#x2F;取值操作,不会触发元方法。<br>也就是，通过rawset和rawget可以忽略表对应的metatable,绕过元表的行为约束，强制对原始的表进行操作，不需要考虑元表的简单更新。</p><p>格式：<br>rawset(table, key, value) ， 它会绕过 __newindex元方法。<br>rawget(table, key) , 它会绕过__index元方法。</p><p>应用：<br>一个典型的应用，在__newindex中通过rawset对表进行赋值，可以避免陷入死循环而爆栈。</p><h3 id="pcall-xpcall-debug"><a href="#pcall-xpcall-debug" class="headerlink" title="pcall,xpcall,debug"></a>pcall,xpcall,debug</h3><h4 id="pcall"><a href="#pcall" class="headerlink" title="pcall"></a>pcall</h4><p>Lua中处理错误，可以使用pcall(protected call)来包装需要执行的代码。<br>类似于C#里面的try-catch提供一种保护机制，当pcall执行的内容发生错误的时候，会返回false，成功时返回true，通过这种形式可以用来捕获函数执行中的任何错误。</p><p>格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> result , errorMsg = <span class="built_in">pcall</span>(functionName, arg1, arg2,...)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 错误处理</span></span><br><span class="line">    <span class="built_in">print</span>(errorMsg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的errorMsg就是发生的错误信息，它会简单显示问题发生的原因。</p><h4 id="xpcall与debug"><a href="#xpcall与debug" class="headerlink" title="xpcall与debug"></a>xpcall与debug</h4><p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。这种时候就可以使用xpcall函数。<br>xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开前调用错误处理函数。</p><p>格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myErrorHandler</span><span class="params">(err)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: &quot;</span>.. err)</span><br><span class="line">    <span class="comment">--或者</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>())</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> result = <span class="built_in">xpcall</span>(myFunction, myErrorHandler，arg1, arg2,...)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这种形式，我们能供直接使用自定义的方法处理错误信息。此时，我们还可以在此自定义方法中使用debug库来获取错误的调用栈等额外信息。<br>debug库提供了两个通用处错误处理函数：</p><ul><li>debug.debug：提供一个Lua提示符，让用户来检查错误的原因</li><li>debug.traceback：根据调用桟来构建一个扩展的错误消息</li></ul><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>在 Lua 中，assert 函数用于检查一个条件是否为真。如果条件为真，assert 会继续执行后续代码；如果条件为假，assert 会抛出一个错误并终止程序执行。</p><p>格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(condition, message)</span><br></pre></td></tr></table></figure><p>message 是可选参数，用于自定义错误信息，如果返回为false，则会抛出这个错误信息，默认为：”assertion failed!”。</p><p>应用：</p><ul><li>输入验证：在函数开始时，验证输入参数是否符合预期。</li><li>调试：在开发过程中，验证某些假设条件是否成立。</li><li>错误处理：在某些关键步骤中，确保条件满足，否则立即终止程序。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="built_in">assert</span>(b ~= <span class="number">0</span>, <span class="string">&quot;除数不能为 0&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">2</span>)) <span class="comment">-- 5.0</span></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">0</span>)) <span class="comment">-- 报错，除数不能为0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="os-time与os-date"><a href="#os-time与os-date" class="headerlink" title="os.time与os.date"></a>os.time与os.date</h3><p>Lua标准库中提供了关于时间的两个方法os.time()与os.date()。</p><h4 id="os-time"><a href="#os-time" class="headerlink" title="os.time()"></a>os.time()</h4><p>os.time()方法可以把一个日期字符串转换为时间戳，它返回一个整数，表示从1970年1月1日8点0分0秒到指定日期的秒数（又名 Unix时间戳）。</p><ol><li>如果传参为空，则返回当前时间转化为秒数的结果。</li><li>传参不为空，可以传入指定的时间，将其转化为秒数。传参格式为table，如果传参的话至少要传入年月日才能确定一个具体的时间。如果小于上述指定时间，则秒数为负数，会得到空值。</li></ol><p>格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> timeTable = &#123;</span><br><span class="line">    year = <span class="number">2025</span>,</span><br><span class="line">    month = <span class="number">1</span>,</span><br><span class="line">    day = <span class="number">12</span>,</span><br><span class="line">    hour = <span class="number">21</span>,</span><br><span class="line">    <span class="built_in">min</span> = <span class="number">36</span>,</span><br><span class="line">    sec == <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>(timeTable))  <span class="comment">--1736717760</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意键值不能写错，必须是year，month，day，hour，min，sec。</p><h4 id="os-date"><a href="#os-date" class="headerlink" title="os.date()"></a>os.date()</h4><p>os.date()方法可以把一个时间戳（Unix时间戳）转换为固定格式的时间，它返回一个字符串，表示指定时间的日期和时间。</p><p>格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> timeTable = &#123;</span><br><span class="line">    year = <span class="number">2025</span>,</span><br><span class="line">    month = <span class="number">1</span>,</span><br><span class="line">    day = <span class="number">12</span>,</span><br><span class="line">    hour = <span class="number">21</span>,</span><br><span class="line">    <span class="built_in">min</span> = <span class="number">36</span>,</span><br><span class="line">    sec == <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> unixTime = <span class="built_in">os</span>.<span class="built_in">time</span>(timeTable)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回指定Unix时间戳转化为表形式的内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dump</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>, unixTime)))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- result:</span></span><br><span class="line"><span class="comment">--  &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--     &quot;day&quot;   = 12      --日</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;hour&quot;  = 21     --小时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;isdst&quot; = false     --是否夏令时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;min&quot;   = 36     --分钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;month&quot; = 1     --月</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;sec&quot;   = 0     --秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;wday&quot;  = 1     --星期几(从周一开始计数1-7)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;yday&quot;  = 12     --当年已过天数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--      &quot;year&quot;  = 2025  --年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--  &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回当前Unix时间戳转化为表形式的内容，格式同上</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dump</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回指定格式的时间字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%Y-%m-%d, %H:%M:%S&quot;</span>,unixTime))   <span class="comment">--2025-01-12, 21:36:00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，要特别注意的是时区问题。<br>一般情况下，如果要联调处理时间功能，往往是服务器端发过来一个时间戳，客户端操作后转化为指定的可读样式。<br>转换之中如果时区不同，则应当进行时区转换。如果有夏令时，则需要额外加上3600秒。</p><h3 id="Lua元表"><a href="#Lua元表" class="headerlink" title="Lua元表"></a>Lua元表</h3><p>元表(MetaTable)的主要作用是用于改变表的行为，每个行为有其对应的元方法。通过这些元方法的赋值，可以将两个table的对应行为进行关联。</p><h4 id="设置和获取元表"><a href="#设置和获取元表" class="headerlink" title="设置和获取元表"></a>设置和获取元表</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对指定table设置元表</span></span><br><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">table</span>, metatable)</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line">myTable = <span class="built_in">setmetatable</span>(&#123;&#125;, metatable)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回指定对象的元表</span></span><br><span class="line"><span class="built_in">getmetatable</span>(<span class="built_in">table</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h4><p>这是 metatable 最常用的键。也是后面实现面向对象的关键的元方法。<br>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index元方法所指向的table或者方法，从而搜寻对应的值。</p><p>格式有两种：</p><ol><li><p>直接赋值一个table：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">myTable = &#123;</span><br><span class="line">    name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myMetatable = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = &#123; age = <span class="number">18</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------设置元表前------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myTable.name)  <span class="comment">-- &quot;Alice&quot;</span></span><br><span class="line"><span class="built_in">print</span>(myTable.age)   <span class="comment">-- nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable, myMetatable)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------设置元表后------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myTable.name)  <span class="comment">-- &quot;Alice&quot;</span></span><br><span class="line"><span class="built_in">print</span>(myTable.age)   <span class="comment">-- 18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种情况下，如果元表里面的__index指向的是表，而此表还有元表，且实现了__index仍然指向表，则会以此类推查找，直到找到值或者返回nil。</p></li><li><p>赋值一个函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">myTable = &#123;</span><br><span class="line">    name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myMetatable = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, key)</span></span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&quot;age&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">18</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------设置元表前------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myTable.name)  <span class="comment">-- &quot;Alice&quot;</span></span><br><span class="line"><span class="built_in">print</span>(myTable.age)   <span class="comment">-- nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable, myMetatable)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------设置元表后------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(myTable.name)  <span class="comment">-- &quot;Alice&quot;</span></span><br><span class="line"><span class="built_in">print</span>(myTable.age)   <span class="comment">-- 18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:</p><ol><li>在表中查找，如果找到，返回该元素，找不到则继续</li><li>判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。</li><li>判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。</li></ol><h4 id="newindex元方法"><a href="#newindex元方法" class="headerlink" title="__newindex元方法"></a>__newindex元方法</h4><p>当你给 table 中的某个键赋值的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__newindex元方法所指向的table或者函数，从而设置对应的值。</p><p>格式同__index元方法。</p><ol><li>赋值为table</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mymetatable = &#123;&#125;</span><br><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, &#123; <span class="built_in">__newindex</span> = mymetatable &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(mytable.key1)   <span class="comment">-- &quot;value1&quot;</span></span><br><span class="line"></span><br><span class="line">mytable.newkey = <span class="string">&quot;新值2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.newkey,mymetatable.newkey) <span class="comment">-- nil  新值2</span></span><br><span class="line"></span><br><span class="line">mytable.key1 = <span class="string">&quot;新值1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mymetatable.key1)  <span class="comment">-- 新值1  nil</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>赋值为函数</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, </span><br><span class="line">&#123; <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, key, value)</span></span> </span><br><span class="line">    <span class="built_in">rawset</span>(<span class="built_in">table</span>, key, value)</span><br><span class="line"><span class="keyword">end</span> &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(mytable.key1)   <span class="comment">-- &quot;value1&quot;</span></span><br><span class="line"></span><br><span class="line">mytable.newkey = <span class="string">&quot;新值2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.newkey) <span class="comment">-- 新值2</span></span><br><span class="line"></span><br><span class="line">mytable.key1 = <span class="string">&quot;新值1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.key1)  <span class="comment">-- 新值1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的赋值不应当直接赋值，而应当使用rawset，上面已经说过，这里不再赘述。</p><h4 id="表操作符"><a href="#表操作符" class="headerlink" title="表操作符"></a>表操作符</h4><table><thead><tr><th>元方法</th><th>对应的运算符</th></tr></thead><tbody><tr><td>__add</td><td>+</td></tr><tr><td>__sub</td><td>-</td></tr><tr><td>__mul</td><td>*</td></tr><tr><td>__div</td><td>&#x2F;</td></tr><tr><td>__mod</td><td>%</td></tr><tr><td>__unm</td><td>-</td></tr><tr><td>__concat</td><td>…</td></tr><tr><td>__eq</td><td>&#x3D;&#x3D;</td></tr><tr><td>__lt</td><td>&lt;</td></tr><tr><td>__le</td><td>&lt;&#x3D;</td></tr></tbody></table><h4 id="call元方法"><a href="#call元方法" class="headerlink" title="__call元方法"></a>__call元方法</h4><p>__call 元方法在 Lua 把一个表当作函数调用时，会调用该元方法。支持自定义传参。<br>其赋值就是一个函数。</p><p>格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mytable = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mytable, &#123; <span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, arg1, arg2,...)</span></span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> <span class="built_in">print</span>(arg1)</span><br><span class="line"><span class="built_in">print</span>(arg2)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span> &#125;)</span><br><span class="line"></span><br><span class="line">mytable(<span class="number">8</span>,<span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="tostring元方法"><a href="#tostring元方法" class="headerlink" title="_tostring元方法"></a>_tostring元方法</h4><p>__tostring 元方法用于修改表的输出行为。也就是print(table)时，会调用该元方法，其指向一个函数，有着对应的返回值。<br>如果不实现这个元方法的话，默认的输出行为是table的地址。</p><p>格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mytable = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(mytable, &#123; <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(table)</span></span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">table</span>) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;mytable&quot;</span></span><br><span class="line"><span class="keyword">end</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable)  <span class="comment">-- 1, 2, 3, mytable</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Lua实现面向对象"><a href="#Lua实现面向对象" class="headerlink" title="Lua实现面向对象"></a>Lua实现面向对象</h3><p>众所周知面向对象的三大特性，继承，多态，封装。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承的实现主要是通过元表的__index元方法来实现。因为继承里面一个很重要的性质就是派生类可以直接使用基类里面的方法和属性，从而减少代码的复用。</p><p>单继承</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基类Base</span></span><br><span class="line">Animal = &#123;</span><br><span class="line">    name = <span class="string">&quot;动物&quot;</span>,</span><br><span class="line">    Eat = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;正在吃东西&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    New = <span class="function"><span class="keyword">function</span><span class="params">(self, o, name)</span></span></span><br><span class="line">        o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">        <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">        <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">        name = name <span class="keyword">or</span> <span class="string">&quot;动物&quot;</span></span><br><span class="line">        <span class="built_in">self</span>.name = name</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 动物对象</span></span><br><span class="line"><span class="keyword">local</span> animal = Animal:New()</span><br><span class="line">animal:Eat()  <span class="comment">-- 动物正在吃东西</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 派生类Cat</span></span><br><span class="line">Cat = Animal:New()</span><br><span class="line"><span class="comment">-- 猫的对象</span></span><br><span class="line"><span class="keyword">local</span> banzai = Cat:New(<span class="literal">nil</span>,<span class="string">&quot;板载&quot;</span>)</span><br><span class="line">banzai:Eat()  <span class="comment">-- 板载正在吃东西</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 派生类Dog</span></span><br><span class="line">Dog = Animal:New(<span class="literal">nil</span>, <span class="string">&quot;狗&quot;</span>)</span><br><span class="line">Dog.hobby = <span class="string">&quot;没有爱好&quot;</span></span><br><span class="line">Dog.New = <span class="function"><span class="keyword">function</span><span class="params">(self, o, name, hobby)</span></span></span><br><span class="line">    o = o <span class="keyword">or</span> Animal:New(o, name)</span><br><span class="line">    <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    name = name <span class="keyword">or</span> <span class="string">&quot;狗&quot;</span></span><br><span class="line">    hobby = hobby <span class="keyword">or</span> <span class="string">&quot;没有爱好&quot;</span></span><br><span class="line">    <span class="built_in">self</span>.hobby = hobby</span><br><span class="line">    <span class="built_in">self</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog.LookingForOutdoors = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;正在期待户外活动&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Dog.ShowHobby = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;的爱好是&quot;</span>..<span class="built_in">self</span>.hobby)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 狗的对象</span></span><br><span class="line"><span class="keyword">local</span> wangcai = Dog:New(<span class="literal">nil</span>, <span class="string">&quot;旺财&quot;</span>)</span><br><span class="line">wangcai:Eat()  <span class="comment">-- 旺财正在吃东西</span></span><br><span class="line">wangcai:LookingForOutdoors()  <span class="comment">-- 旺财正在期待户外活动</span></span><br><span class="line">wangcai:ShowHobby()  <span class="comment">-- 旺财的爱好是散步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dog的派生类哈士奇</span></span><br><span class="line">Husky = Dog:New(<span class="literal">nil</span>, <span class="string">&quot;哈士奇&quot;</span>)</span><br><span class="line">Husky.StartToDestroyHouse = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;已经迫不及待开始破坏了&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> husky = Husky:New(<span class="literal">nil</span>, <span class="string">&quot;小哈士奇&quot;</span>,<span class="string">&quot;拆家&quot;</span>)</span><br><span class="line">husky:Eat()  <span class="comment">-- 小哈士奇正在吃东西</span></span><br><span class="line">husky:LookingForOutdoors()  <span class="comment">-- 小哈士奇正在期待户外活动</span></span><br><span class="line">husky:ShowHobby()  <span class="comment">-- 小哈士奇的爱好是拆家</span></span><br><span class="line">husky:StartToDestroyHouse()  <span class="comment">-- 小哈士奇已经迫不及待开始破坏了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--报错示范</span></span><br><span class="line">Cat:ShowHobby()  <span class="comment">-- attempt to call a nil value (method &#x27;ShowHobby&#x27;)</span></span><br><span class="line"></span><br><span class="line">wangcai:StartToDestroyHouse()  <span class="comment">-- attempt to call a nil value (method &#x27;StartToDestroyHouse&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多继承<br>不错，Lua是可以实现多继承的。在类的基础上实现多继承的方式中__index指向的就不再是单一的table了，而是一个函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 基类Base 动物</span></span><br><span class="line">Animal = &#123;</span><br><span class="line">    name = <span class="string">&quot;动物&quot;</span>,</span><br><span class="line">    Eat = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;正在吃东西&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    New = <span class="function"><span class="keyword">function</span><span class="params">(self, o, name)</span></span></span><br><span class="line">        o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">        <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">        <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">        name = name <span class="keyword">or</span> <span class="string">&quot;动物&quot;</span></span><br><span class="line">        <span class="built_in">self</span>.name = name</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基类Base 四足动物</span></span><br><span class="line">Quadruped = &#123;</span><br><span class="line">    Declare = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.name .. <span class="string">&quot;有四条腿&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动物对象</span></span><br><span class="line">Cat = Animal:New()</span><br><span class="line">Cat.Bases = &#123;Animal,Quadruped&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(Cat, &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, key)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">table</span>.Bases) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v[key] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> v[key]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> banzai = Cat:New(<span class="literal">nil</span>,<span class="string">&quot;板载&quot;</span>)</span><br><span class="line">banzai:Eat()  <span class="comment">-- 板载正在吃东西</span></span><br><span class="line">banzai:Declare()  <span class="comment">-- 板载有四条腿</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Lua重要知识点"><a href="#Lua重要知识点" class="headerlink" title="Lua重要知识点"></a>Lua重要知识点</h2><p>这个部分的每个知识点都能拓展很多，这里挑一些要点简要说明，把一些以重要且易混淆的地方呈现出来，对此更深层的实现原理和进一步的拓展感兴趣的可以在参考文档中找到对应的模块自行查阅。</p><h3 id="require加载机制"><a href="#require加载机制" class="headerlink" title="require加载机制"></a>require加载机制</h3><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><blockquote><p>模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。<br>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。</p></blockquote><p>在实际使用lua的开发中，无论是管理器，功能通用功能类，已经mvc各层都是通过模块的形式去进行封装的。必要时，其他地方可以通过require进行引入。</p><h4 id="require加载策略的优化"><a href="#require加载策略的优化" class="headerlink" title="require加载策略的优化"></a>require加载策略的优化</h4><p>lua中require的加载，它本身其实是具有懒加载的特性的，当一个模块被require之后，会缓存到package.loaded里面，它会一直保存在内存中，直到显式地将其从package.loaded里面移除。</p><p>这里要引入两个情况 <strong>循环加载</strong> 和 <strong>冗余占用</strong></p><ul><li><strong>循环引用。在Lua中，模块之间的循环引用是指两个或多个模块相互require，会形成一个闭环。</strong></li><li><strong>冗余占用。在Lua中，在声明引入了一个模块后，可能根据功能使用情况，并不会用到这个模块的功能，这就照成了没有必要的消耗。</strong></li></ul><p><strong>Lua自身的处理机制：</strong><br>针对循环加载，Lua的模块加载机制是可以处理这种情况的。当一个模块处于加载中，尚未加载完成的时候，会设置一个Flag标识符，来表示当前模块尚未加载完成。<br>因此，即使模块A中包含了加载模块B的代码，而模块B中又有加载模块A的代码。当我们加载A时，A会加载模块B，而B中则会开始加载模块A，但此时得到了模块A还没加载完的标识，便不再继续，从而避免了循环引用。<br>而针对冗余占用，有些可能是程序在开发中不规范导致的；而有些则是没有办法，因为有些功能分支本来就是需要应对可能需要用到的情况。</p><p>在这样情况下，我们还能进一步进行优化。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---懒加载自定义，我们可以在初始化定义的时候定义一下</span></span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">require</span> = <span class="built_in">require</span> <span class="string">&quot;lazyRequire&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Lua的懒加载模块：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> packLoaded = <span class="built_in">package</span>.<span class="built_in">loaded</span></span><br><span class="line"><span class="comment">---@type function realRequire 定义原始的require</span></span><br><span class="line"><span class="built_in">_G</span>.realRequire = <span class="built_in">_G</span>.<span class="built_in">require</span></span><br><span class="line">                                  </span><br><span class="line"><span class="comment">---@type table 存放懒加载模块，对同一模块的懒加载返回相同表，模块真正加载后移除</span></span><br><span class="line"><span class="keyword">local</span> tableLazyRequire = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">---@type table lazyRequire返回的表共用元表，从懒加载模块取值会触发__index，真正require模块，并从里面获取值</span></span><br><span class="line"><span class="keyword">local</span> lazyMetaTable = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">        <span class="keyword">local</span> moduleName = t.xcModuleName</span><br><span class="line">        <span class="keyword">local</span> realTable = realRequire(moduleName)</span><br><span class="line">        <span class="built_in">setmetatable</span>(t, &#123; <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, key)</span></span></span><br><span class="line">            <span class="keyword">local</span> value = realTable[key]</span><br><span class="line">            <span class="keyword">if</span> value ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>[key] = value</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span> &#125;)</span><br><span class="line">        tableLazyRequire[moduleName] = <span class="literal">nil</span></span><br><span class="line">        t.xcModuleName = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> realTable[k]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">---lazyRequire 懒加载模块，避免循环引用， 会多一次index</span></span><br><span class="line"><span class="comment">---故意暴露在全局</span></span><br><span class="line"><span class="comment">---@param name string 模块名，同require的参数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">lazyRequire</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="comment">--首先，会从系统require表取</span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">module</span> = packLoaded[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">module</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--其次，再从懒加载表取</span></span><br><span class="line">    <span class="built_in">module</span> = tableLazyRequire[name]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">module</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--最后，如果两者都没有，则会创建新表并放入懒加载表，返回的module便是此表</span></span><br><span class="line">    <span class="built_in">module</span> = <span class="built_in">setmetatable</span>(&#123; xcModuleName = name &#125;, lazyMetaTable)</span><br><span class="line">    tableLazyRequire[name] = <span class="built_in">module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">_G</span>.lazyRequire = lazyRequire</span><br><span class="line"><span class="keyword">return</span> lazyRequire</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这里我们看到，加了一层tableLazyRequire来进行缓存，也就是说在初步定义的时候并没有去真正加载，返回的也并不是对应的模块，而是指向对应模块的缓存表；当这个模块的功能真正被使用的时候，再去真正的加载对应的模块，然后置空其在tableLazyRequire里面的缓存。</p><p>以此便解决了循环引用和冗余占用的问题。</p><h3 id="Lua的浅拷贝与深拷贝"><a href="#Lua的浅拷贝与深拷贝" class="headerlink" title="Lua的浅拷贝与深拷贝"></a>Lua的浅拷贝与深拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝发生在直接使用 赋值运算符”&#x3D;”的时候。</p><ul><li><p>对于基本类型，会直接进行复制，创建出一个新的对象，两者互不影响。这里的基本类型也就是Lua中除了table以外的类型。</p></li><li><p>对于table类型，则是进行引用，只是增加了一个指针指向已经存在的内存地址，如果原地址内容发生变化，则浅拷贝出来的对象也会发生变化。</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">1</span> </span><br><span class="line"><span class="keyword">local</span> b = a</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment">-- 1</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment">-- 2</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">local</span> str2 = str</span><br><span class="line"><span class="built_in">print</span>(str)  <span class="comment">-- hello</span></span><br><span class="line"><span class="built_in">print</span>(str2)  <span class="comment">-- hello</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str)  <span class="comment">-- world</span></span><br><span class="line"><span class="built_in">print</span>(str2)  <span class="comment">-- hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">local</span> t2 = t1</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">PrintTable</span><span class="params">(t,prefix)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------------&quot;</span>..prefix ..<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i , v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">PrintTable(t1,<span class="string">&quot;t1&quot;</span>)  <span class="comment">-- 1,2,3</span></span><br><span class="line">PrintTable(t2,<span class="string">&quot;t2&quot;</span>)  <span class="comment">-- 1,2,3</span></span><br><span class="line"></span><br><span class="line">t1[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">PrintTable(t1,<span class="string">&quot;t1&quot;</span>)  <span class="comment">-- 4,2,3</span></span><br><span class="line">PrintTable(t2,<span class="string">&quot;t2&quot;</span>)  <span class="comment">-- 4,2,3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝主要是应用于table类型。它会增加一个新的指针并申请新的内存，把原来table中的所有值拷贝一份到新内存中，并让这个新增的指针指向这个新开的内存，从而实现深拷贝。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepCopy</span><span class="params">(object)</span></span></span><br><span class="line">    <span class="keyword">local</span> lookup_table = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_copy</span><span class="params">(object)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(object) ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> object</span><br><span class="line">        <span class="keyword">elseif</span> lookup_table[object] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> lookup_table[object]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> new_table = &#123;&#125;</span><br><span class="line">        lookup_table[object] = new_table</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(object) <span class="keyword">do</span></span><br><span class="line">            new_table[_copy(key)] = _copy(value)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setmetatable</span>(new_table, <span class="built_in">getmetatable</span>(object))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> _copy(object)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Animal = &#123;</span><br><span class="line">    name = <span class="string">&quot;动物&quot;</span>,</span><br><span class="line">    Eat = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;正在吃东西&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">    Habit = &#123;</span><br><span class="line">        [<span class="number">1</span>] =<span class="string">&quot;睡觉&quot;</span>,</span><br><span class="line">        [<span class="number">2</span>] =<span class="string">&quot;吃饭&quot;</span>,</span><br><span class="line">        [<span class="number">3</span>] =<span class="string">&quot;玩耍&quot;</span></span><br><span class="line">    &#125;,  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> deepCopyAnimal = DeepCopy(Animal)</span><br><span class="line"></span><br><span class="line">Animal.Habit[<span class="number">1</span>] = <span class="string">&quot;新的睡觉&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Animal.Habit[<span class="number">1</span>])  <span class="comment">-- 新的睡觉</span></span><br><span class="line"><span class="built_in">print</span>(deepCopyAnimal.Habit[<span class="number">1</span>])  <span class="comment">-- 睡觉</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="userdata"><a href="#userdata" class="headerlink" title="userdata"></a>userdata</h3><p>full userdata 表示一个原始的内存块，可以存储任何东西，它是一个类似于table的object，必须事先创建（也可以被垃圾收集器回收），它也有自己的metatable，它只等于其自身。</p><p>可以为每种full userdata 创建一个唯一的元表，来辨别不同类型的userdata，每当创建了一个userdata后，就用相应的元表（放在Registry中）来标记它，而每得到一个userdata后，就检查它是否拥有正确的元表。</p><p>Lua在释放full userdata所关联的内存时，若发现userdata对应的元表还有__gc元方法，则会调用这个方法，并以userdata自身作为参数传入。利用该特性，可以再回收userdata的同时，释放与此userdata相关联的资源。</p><p>轻量级userdata是一种表示C指针的值(即void*)，要将一个轻量级userdata放入栈中，只需要调用lua_pushlightuserdata即可。轻量级userdata只是一个指针而已。它没有元表，就像数字一样，轻量级userdata无须受垃圾收集器的管理。</p><p>Lua在释放完全userdata所关联的内存时，若发现userdata对应的元表还有__gc元方法，则会调用这个方法，并以userdata自身作为参数传入。利用该特性，可以再回收userdata的同时，释放与此userdata相关联的资源。</p><p>它在和其他语言交互时候，起到了很关键的作用，这个到时候可以细讲。</p><h3 id="闭包-closure-与upvalue"><a href="#闭包-closure-与upvalue" class="headerlink" title="闭包(closure)与upvalue"></a>闭包(closure)与upvalue</h3><p>闭包(closure)指的是在运行期间，任何时候只要Lua执行了一个function…end表达式，就会创建于一个新的数据对象，这个数据对象，就是闭包。<br>每个闭包由两部分组成，分别是对其函数的引用，对一个元素是对upvalue引用的数组的引用。在5.2版本之前，其实还包含着一个对环境的引用。</p><p>其最大的特征在于包含了成员对upvalue引用的数组的引用，如果没有这一点的话，闭包的行为更像是一个普通的函数引用，因为它没有捕获任何额外的局部环境。这也是函数和闭包的区别，有时候我们获取或者定义函数的时候，如果其包含了对upvalue的引用则严格意义上讲，它表示的其实不是函数，而是闭包。要说明这一点首先要说一下Lua函数的性质。</p><h4 id="Lua函数的性质"><a href="#Lua函数的性质" class="headerlink" title="Lua函数的性质"></a>Lua函数的性质</h4><p>函数其实是算作第一类型值(First-Class Value)，这种类型具有特定的词法作用域(Lexical Scoping)。前者意味着函数能像数组，字符串，表那样被操作(传参，赋值，运行时创建)，而我们讨论函数的时候，实际上讨论的是指向对应函数的变量。后者则表示函数在其定义的时候可以访问其定义时所在环境中的变量，这种作用域是静态的，即在编译时确定，而不是运行时，这使得函数能够记住其特定的上下文，包括局部变量。<br>这也说明了，函数其实是编译时期的概念，是静态的；而闭包是运行时的概念，是动态的。</p><h4 id="Upvalue"><a href="#Upvalue" class="headerlink" title="Upvalue"></a>Upvalue</h4><p>闭包中，对于任何外层局部变量的存取都是间接通过upvalue来进行。upvalue最初指向栈中变量活跃的地方，当其离开变量作用域(超过变量生存期)的时候，此变量会被复制到upvalue中。注意，这里的“复制”指的是upvalue的指针会指向对应的变量。</p><p>通过为每个变量创建一个upValue并按照需要重复利用这个upvalue，保证了未决状态（未超过生命周期）的局部变量都能够在闭包之前正确地共享，没错，这里说的是共享。</p><p>结构上，Lua会使用并维护一条链表，该链表的每一个节点都会对应一个打开(open)的upvalue，这里的打开指的是当前正指向栈局部变量的upvalue。</p><p>流程中，当Lua创建一个新的闭包，Lua会遍历当前函数所有的外部局部变量，对于每一个外部的局部变量，若在上面的链表中能找到该变量，则会重复使用对应打开的upvalue，这也是能共享的原因；如果不能找到，则会创建一个新的打开的upvalue，并把它插入链表中。当局部变量离开作用域的时候，这个的upvalue就会变成关闭状态(closed upvalue)，并会被移除链表，此时闭包中对应的数组还是引用着对应的upvalue的，这也是离开作用域后，我们任然能获取的原因。一旦某个关闭的upvalue不再被任何闭包引用，那么它的存储空间就会被回收。</p><img src="/img/lua_closure.png" class="post-image" /><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>一个函数可能存取其更外层函数而非直接外层函数的局部变量。在这种情况下，当创建闭包的时候，这个局部变量便可能不在栈中（离开了作用域），也就是进入了close状态，只收到更外层函数闭包里数组的引用，从而导致无法获取。</p><p>Lua使用flat闭包（flat closures）来处理这种情况，其核心思想就是将所有被捕获的外部局部变量都存储在闭包的直接外层函数的闭包中，即使这些变量位于更外层的函数。flat闭包的时候，无论何时一个函数访问一个外部的局部变量并且该变量不再在直接外部函数中，该变量也会进入直接外部函数的闭包中。</p><h4 id="简结"><a href="#简结" class="headerlink" title="简结"></a>简结</h4><p>我们可以通过一个例子来说明上面的各种情况：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">(n)</span></span></span><br><span class="line">   <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">inner1</span><span class="params">()</span></span></span><br><span class="line">         <span class="built_in">print</span>(n)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">inner2</span><span class="params">()</span></span></span><br><span class="line">         n = n + <span class="number">10</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">return</span> inner1,inner2</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">return</span> foo</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------&quot;</span>)</span><br><span class="line">t = Test(<span class="number">2015</span>)</span><br><span class="line">f1,f2 = t()</span><br><span class="line">f1()        <span class="comment">-- 打印2015</span></span><br><span class="line"></span><br><span class="line">f2()</span><br><span class="line">f1()        <span class="comment">-- 打印2025</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">g1,g2 = t()</span><br><span class="line">g1()        <span class="comment">-- 打印2025</span></span><br><span class="line"></span><br><span class="line">g2()</span><br><span class="line">g1()        <span class="comment">-- 打印2035</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------&quot;</span>)</span><br><span class="line">f1()        <span class="comment">-- 打印2035</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------------------------------&quot;</span>)</span><br><span class="line">t2 = Test(<span class="number">2001</span>)</span><br><span class="line">w1 , w2 = t2()</span><br><span class="line">w1()        <span class="comment">-- 打印2001</span></span><br><span class="line"></span><br><span class="line">w2()    </span><br><span class="line">w1()        <span class="comment">-- 打印2011</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这个例子，我们可以发现之前知识点的应用：</p><ul><li>首先作为第一类型值，函数可以作为参数传递，也可以作为返回值返回。上面的test，foo的返回值都是函数，而foo，inner1，inner2则被当做返回值。</li><li>分析 Test 函数结构我们能得知。n作为传参传入Test函数中，foo函数的直接外部变量只有n，而inner1和inner2作为foo函数的内部变量，都没有直接外部变量，但其更外层有一个n，且两个函数中都有对于n的使用。</li><li>在执行Test的过程中，Lua链表中会创建并打开一个upvalue，让其指向n，此时此upvalue的状态为open，它最先被Test闭包引用；在执行foo函数中的inner1和inner2时候，这两个闭包在创建时堆栈上无法找到n的踪影，则会以flat闭包的形式来处理这种情况，直接使用闭包foo的upvalue来引用n。而执行 t &#x3D; Test(2015) 之后，t这个闭包已经把n拓展保管好了，之后f1和f2用n的时候，就从外层闭包的upvalue中去找，直到找到对应引用并拷贝到自己的upvalue引用数组中，也正是因为如此，f1,f2,g1,g2所引用的upvalue其实都是指向的同一个变量。</li><li>t2 &#x3D; Test(2001)的过程是创建一个新的闭包和原来的t闭包没有关系，因此其执行和结果自然也不相干。</li></ul><h3 id="table的底层实现"><a href="#table的底层实现" class="headerlink" title="table的底层实现"></a>table的底层实现</h3><p>在上面pairs和ipairs里面提了一嘴，Lua中table的存储主要是由两部分组成，数组和哈希表，对于数组的下表是从1开始；而对于哈希表而言，只要非整数键和超过数组范围n的整数键对应的值将被存入哈希表部分。</p><h4 id="查找算法的实现"><a href="#查找算法的实现" class="headerlink" title="查找算法的实现"></a>查找算法的实现</h4><p>当我们往table中传入key值，尝试获取其值的时候，就会触发其查找流程。<br>如果当前key为整数且key大于等于0且小于等于数组的大小，则会首先从数组部分进行查找，否则就会从哈希表部分进行查找。后者会计算出该key值的哈希值，然后遍历哈希表找到对应的值。</p><p>举个简单的例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;,</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">10</span>,</span><br><span class="line">t[<span class="number">100</span>] = <span class="number">0</span>,</span><br></pre></td></tr></table></figure><p>根据上面的规则，我们可以清楚明白的确定，key为1是从数组里面进行查找，key为100则是从哈希表中查找（因为1小于数组的大小，100明显大于数组的大小）。</p><h4 id="新增元素的实现原理"><a href="#新增元素的实现原理" class="headerlink" title="新增元素的实现原理"></a>新增元素的实现原理</h4><p>给Lua中添加新元素的时候，对于key值超过数组大小，都会存储于哈希表部分，从而引发哈希表的rehash。<br>rehash过程中，会对table重新规划hash和数组部分的大小。首先会清空数组，然后计算数组部分的大小和范围，再计算哈希表中key的数量和范围，最后进行重新分配。<br>上面过程中两部分值得注意的点是：</p><ul><li>新的数组部分大小是满足以下条件的最大n值：1到n之间至少一半的空间会被利用，这是为了避免像稀疏数组一样浪费空间。并且n&#x2F;2 + 1到n之间的空间需要至少有一个被利用，这是避免n&#x2F;2个个空间能容纳所有数组的时候申请n个空间造成浪费。</li><li>哈希部分则会采用闭散列的算法，它会把有冲突的key存于空闲槽位，从而避免了额外分配内存。</li></ul><p>举个简单的例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">t[<span class="number">3</span>] = <span class="number">30</span></span><br><span class="line">t[<span class="number">5</span>] = <span class="number">50</span></span><br><span class="line">t[<span class="number">100</span>] = <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据上面的规则我们就可以得到其分配情况：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array_part = &#123;</span><br><span class="line">  [<span class="number">1</span>] = <span class="number">10</span>,</span><br><span class="line">  [<span class="number">2</span>] = <span class="literal">nil</span>,  <span class="comment">-- 可能会有，也可能没有，取决于内部实现</span></span><br><span class="line">  [<span class="number">3</span>] = <span class="number">30</span>,</span><br><span class="line">  [<span class="number">4</span>] = <span class="literal">nil</span>,  <span class="comment">-- 可能会有，也可能没有，取决于内部实现</span></span><br><span class="line">  [<span class="number">5</span>] = <span class="number">50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash_part = &#123;</span><br><span class="line">  [<span class="number">100</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还有一个重点，是关于表中隐式key值数组成员，这一点在遍历关键字的内容中已经初步说过了，这里为了方便说明，我们再用一下那个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> mixTable = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    [<span class="number">4</span>] = <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    [<span class="number">6</span>] = <span class="number">6</span>,</span><br><span class="line">    <span class="literal">nil</span>,</span><br><span class="line">    [<span class="number">8</span>] = <span class="number">8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面也讲过，此表真正的形式可以表示为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">3</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="literal">nil</span>,</span><br><span class="line">    [<span class="number">4</span>] = <span class="number">4</span>,</span><br><span class="line">    [<span class="number">6</span>] = <span class="number">6</span>,</span><br><span class="line">    [<span class="number">8</span>] = <span class="number">8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表根据结构可以得知，它是完全存于数组部分的，没有哈希部分的内容。然而，对于原来的 [1] &#x3D; 1, [2] &#x3D; 2 是和隐式的 3 和 “hello world ” 冲突，受到了替换。这是因为在键值对定义和隐式数组成员的情况下，Lua会优先考虑数组部分的定义，以这种形式来解决掉冲突。</p><h4 id="结构设计的优点"><a href="#结构设计的优点" class="headerlink" title="结构设计的优点"></a>结构设计的优点</h4><ol><li>存取整数数组部分的键值很快，因为无需计算哈希值。</li><li>操作简单，容易上手。无需开发者手动干预，Lua则会自动根据键值特性进行处理。</li><li>灵活性强。当表只需要被当做数组使用的时候，它就具备数组的性能，且无需承担哈希表部分的开销，反之亦然。</li></ol><h3 id="Lua编译器，解释器和虚拟机"><a href="#Lua编译器，解释器和虚拟机" class="headerlink" title="Lua编译器，解释器和虚拟机"></a>Lua编译器，解释器和虚拟机</h3><p>为了达到较高的执行效率，Lua代码并不是直接被Lua解释器解释执行，而是会先编译为字节码，然后再交给Lua虚拟机去执行，这是一个将高级语言转化为低级指令并执行的过程。</p><h4 id="Lua编译器"><a href="#Lua编译器" class="headerlink" title="Lua编译器"></a>Lua编译器</h4><p>Lua编译器的主要任务是将Lua源代码(就是纯文本文件)转换为字节码或者某种中间表示形式。编译器再编译的过程中会进行词法分析，语法分析，语义分析等，最终生成可以执行的字节码。这些字节码不是直接由机器执行的机器码，而是由Lua虚拟机解释执行的指令集。</p><p>Lua代码称为chunk，编译成的字节码则称为二进制chunk（Binary chunk）。编译器以函数为单位对源代码进行编译，每个函数会被编译成一个称之为原型（Prototype）的结构。</p><p>在整个将高级语言转化为低级指令的过程中，目的是使得源代码能够被虚拟机理解和执行。编译器在这里为源代码和虚拟机之间进行连接打开了通道。</p><h4 id="Lua解释器"><a href="#Lua解释器" class="headerlink" title="Lua解释器"></a>Lua解释器</h4><p>Lua解释器则负责执行由编译器生成的字节码。解释器会逐条读取字节码，并将其转换为虚拟机可以执行的指令。 解释器与虚拟机紧密配合，确保字节码的正确执行。</p><h4 id="Lua虚拟机"><a href="#Lua虚拟机" class="headerlink" title="Lua虚拟机"></a>Lua虚拟机</h4><p>虚拟机相当于物理机，通过借助于操作系统对物理机器（CPU等硬件）的一种模拟、抽象，主要扮演CPU和内存的作用。<br>它主要是是用来执行解释器传递的字节码中的指令，管理全局状态(global_state)、数据栈(StackValue)和函数调用链状态(CallInfo)。<br>当解释器读取并解释字节码时，它会调用虚拟机的指令来执行相应的操作。虚拟机的存在使得Lua代码可以在不同的操作系统和硬件平台上运行，而无需进行大量的修改。</p><p>此外，虚拟机可以分为基于寄存器VM（Register Base 和栈VM两种）和栈VM（Stack Base VM）两种。前者包括操作码和操作数，指令只有一条；后者只有操作码，操作数需要从栈里面获取，处理完再压入栈。中。也正是因此，前者可以减少出入栈的数据拷贝操作和生成指令，虽说其单条指令长度较长，但其效率还是相对高些。</p><h3 id="gc方式与原理"><a href="#gc方式与原理" class="headerlink" title="gc方式与原理"></a>gc方式与原理</h3><p>gc也就是垃圾回收机制，是指自动释放不再使用的内存，以节省内存开销的过程。GC 的性能表现对整个系统的性能表现影响重大。Go 语言早期就是因为 GC 问题而饱受诟病。如果我们把 GC 关闭，那么 CPU 就完全没有额外开销，但是会有极大的内存开销；如果我们每次分配新对象都运行一遍 GC ，那么就不会有任何额外的内存开销，但是 CPU 开销会完全不可接受。</p><p>在 Lua 5.0 以前，Lua 使用的是一个非常简单的标记扫描算法。它从根集开始遍历对象，把能遍历到的对象标记为活对象；然后再遍历通过分配器分配出来的对象全集链表，把没有标记为活对象的其它对象都删除。</p><p>而Lua 5.0 支持 userdata ，它可以有 __gc 方法，当 userdata 被回收时，会调用这个方法。所以，一遍标记是不够的，不能简单的把死掉的 userdata 简单剔除，那样就无法正确的调用 __gc 了。所以标记流程需要分两个阶段做，第一阶段把包括 userdata 在内的死对象剔除出去，然后在死对象中找回有 __gc 方法的，对它们再做一次标记复活相关的对象，这样才能保证 userdata 的 __gc 可以正确运行。执行完 __gc 的 userdata 最终会在下一轮 gc 中释放（如果没有在 __gc 中复活）。 userdata 有一个单向标记，标记 __gc 方法是否有运行过，这可以保证 userdata 的 __gc 只会执行一次，即使在 __gc 中复活（重新被根集引用），也不会再次分离出来反复运行 finalizer 。也就是说，运行过 finalizer 的 userdata 就永久变成了一个没有 finalizer 的 userdata 了。<br>针对CPU和内存开销的取舍情况，Lua 5.0 采用的是一个折中的方案：每当内存分配总量超过上次 GC 后的两倍，就跑一遍新的 GC 流程。</p><p>从 Lua 5.1 开始，Lua 实现了一个步进式垃圾收集器。这个新的垃圾收集器会在虚拟机的正常指令逻辑间交错分布运行，尽量把每步的执行时间减到合理的范围。<br>而此版本采用了一种叫做三色标记的算法。每个对象都有三个状态：</p><ul><li>白色。无法被访问到的对象是白色</li><li>灰色。可访问到，但没有递归扫描完全的对象</li><li>黑色。完全扫描过的对象</li></ul><p>我们可以假定在任何时间点，下列条件始终成立：</p><ol><li>所有被根集引用的对象要么是黑色，要么是灰色的。</li><li>黑色的对象不可能指向白色的。</li><li>白色对象集就是日后会被回收的部分；黑色对象集就是需要保留的部分；灰色对象集是黑色集和白色集的边界。</li></ol><p>随着收集器的运作，通过充分遍历灰色对象，就可以把它们转变为黑色对象，从而扩大黑色集。一旦所有灰色对象消失，收集过程也就完成了。</p><p>步进式 GC 比全量 GC 复杂，不能再只用一个量来控制 GC 的工作时间。对于全量 GC ，我们能调节的是 GC 的发生时机，对于 lua 5.0 ，就是 2 倍上次 GC 后的内存使用量；在 5.1 以后的版本中，这个 2 倍可以由 LUA_GCSETPAUSE 调节。另外增加了 LUA_GCSETSTEPMUL 来控制 GC 推进的速度，默认是 2 ，也就是新增内存速度的两倍。lua 用扫描内存的字节数和清理内存的字节数作为衡量工作进度的标准，有在使用的内存需要标记，没在使用的内存需要清理，GC 一个循环大约就需要处理所有已分配的内存数量的总量的工作。这里 2 是个经验数字，通常可以保证内存清理流程可以跑的比新增要快。</p><p>在Lua5.2中，曾经引入分代gc，以一个试验特性提供，后来因为没有收到太多正面反馈，又在Lua5.3中移除。事实上Lua5.2提供的分代GC过于简单，的确有设计问题，未能很好的解决问题，在还没有发布的Lua5.4中，分代GC被重新设计实现。</p><h3 id="Lua热更新-热重载"><a href="#Lua热更新-热重载" class="headerlink" title="Lua热更新(热重载)"></a>Lua热更新(热重载)</h3><blockquote><p>这里的热更新指的是游戏运行中Lua虚拟机启动后，对代码逻辑修改后直接生效，不需重启游戏，常用于开发过程中调试，不是指游戏启动时的版本更新。</p></blockquote><p>Lua侧热更新的主要用途在本人这里主要是用于方便重写Lua呈逻辑后，不重启编辑器就可以看到效果，方便快速验证代码和确认效果。比如在制作动效，调试功能BUG等相关场景的时候能够提高效率。但在使用中，upvalue的丢失和框架模块引用嵌套层太多需要重新确定引用过于繁琐，也确定了目前这方面的应用目前只能写作一个小工具便捷开发。</p><p>回归上面在讲require的时候，我们说到，require加载一个模块(lua文件)后，会存放到package.loaded中，如果再次require这个模块，就会直接从package.loaded中取出，而不会再次冗余加载。<br>package.loaded本身就是一个Table,其主要包含了：</p><ul><li>_G全局大G表。</li><li>默认加载的模块(string,debug,package,io,os,table,math,coroutine)</li><li>用户加载的模块。</li></ul><p>根据这种情况，可以直接得到一个简单暴力的重载方式：将package.loaded中对应的模块删除，然后再require，就能实现模块的初步更新；之后只需要把其他引用了旧模块的地方进行更新，就可以实现一个简单的热更新效果。</p><p>这里</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reload_module</span><span class="params">(module_name)</span></span></span><br><span class="line">    <span class="keyword">local</span> old_module = <span class="built_in">_G</span>[module_name]</span><br><span class="line">    <span class="built_in">package</span>.<span class="built_in">loaded</span>[module_name] = <span class="literal">nil</span></span><br><span class="line">    <span class="built_in">require</span> (module_name)</span><br><span class="line">    <span class="keyword">local</span> new_module = <span class="built_in">_G</span>[module_name]</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(new_module) <span class="keyword">do</span></span><br><span class="line">        old_module[k] = v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">package</span>.<span class="built_in">loaded</span>[module_name] = old_module</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的写法可以实现初步的跟新，但实际上还需要把对应引用的地方也进行更新才行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章就是这样，希望能够对你有所帮助，当然如果你发现有任何错误的地方，欢迎指出。</p><p>话说回来，随着游戏行业的发展以及越来越多热更技术的兴起和成熟，Lua仿佛确实越来越过时了，就连 xLua 作者、司内大佬 johnche 也从 Lua 转向 JavaScript&#x2F;TypeScript，开发了新一代热更新框架 PuerTS。而如果不是其历史包袱，IOS平台限制反射等因素，也许Lua热更新方案的使用趋势可能会更糟糕一些。<br>但无论是从一开始质疑和细数lua的“十宗罪”，到Lua热更方案成为一时主流，再到一部分人高呼“Lua已经过时了”。<br>但Lua本身始终也只是发挥着其能发挥的作用的，正如codedump在《Lua的设计与实现》中所说的，Lua专注做一个配角，作为胶水语言来辅助像是C,C++这样的主角来更好地完成工作，当其他语言在功前面攻城拔寨的时候，它在后方完成自己辅助的作用，Lua始终恪守本分地做好自己胶水语言的本职工作，可谓“上善若水，水善万物而不争”。</p><p>最后，新年快到了，祝大家新年快乐，工作和学习的同时，也要身体健健康康的。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>《Lua的设计与实现》 - codedump</li><li><a href="https://www.runoob.com/lua/lua-error-handling.html">Lua教程</a></li><li><a href="https://www.drflower.top/posts/43f53d35/">花卷的Lua知识点整理</a></li><li><a href="https://blog.csdn.net/qq826364410/article/details/105659241">鹅厂小哥的遍历关键字差异</a></li><li><a href="https://cjjkkk.github.io/ipairs-pairs-in-lua/">CH33的lua中迭代器pairs和ipairs的比较</a></li><li><a href="https://blog.csdn.net/haobaworenle/article/details/70262047">Lua的rawset和rawget浅析</a></li><li><a href="https://blog.csdn.net/fightsyj/article/details/85055342">Lua中的浅拷贝和深拷贝</a></li><li><a href="https://blog.csdn.net/qq826364410/article/details/88672091">Lua中的userdata</a></li><li><a href="https://www.cnblogs.com/herenzhiming/articles/6101767.html">Lua中的userdata-何人之名</a></li><li><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua 5.0</a></li><li><a href="https://blog.csdn.net/MaximusZhou/article/details/44280109">深入理解Lua的闭包</a></li><li><a href="https://www.cnblogs.com/zblade/p/8819609.html">Lua中table的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/97830462">深入Lua：Table的实现</a></li><li><a href="https://blog.codingnow.com/2018/10/lua_gc.html">Lua GC 的工作原理——云风</a></li><li><a href="https://zhuanlan.zhihu.com/p/600201746">深入Lua虚拟机</a></li><li><a href="https://blog.csdn.net/kk_flying/article/details/138258231">Lua编译器和lua解释器、lua虚拟机的区别</a></li><li><a href="https://blog.codingnow.com/2008/03/hot_update.html">Lua热更新系统设计要点</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年度总结</title>
      <link href="/2025/01/01/summary_annual/"/>
      <url>/2025/01/01/summary_annual/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“写一篇年终总结”，去年虽已有了这个想法，一旦下笔虽是思绪万千却不知所语。今年阅历和见识兴许也增加了几分，加上博客也算是搭建起来了，怀揣着过往的遗憾，历经的回忆，自我的审视以及未来的期待，想着在此写下2024的总结。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>今年作为一名UI仔主要还是对UI方面业务逻辑和性能优化的研究和拓展，以及对GF部分功能模块的一个研究总结（更新ing）。<br>将写笔记位置从Notion也逐步转移到博客上面，尝试用向别人解释的角度去阐述自己想要表达的知识点，这种感觉要“麻烦”很多，主要体现在两个方面：</p><ul><li>表达的方式。因为在写的时候要不断地从自己和读者的视角来回切换，并且注意自己的表达方式不要让人产生误解。是否把简单的东西讲的冗余了呢，是否把该详尽的东西给省略了呢，在时间和精力受限的情况下能否把我想表达的东西表达清楚呢以及我了解到的和我想要表的东西是否存在错误的地方呢，这些都需要进行考虑。从目前的结果上回过头来审视一下自己，只能说缺乏经验以及还有很大进步空间。</li><li>研究的深度。“把复杂的事情说明白了，才能融会贯通，才能提高档次，不然我把代码给GPT转出来一个也是文章” 这方面自然是越深入越透彻越好，在研究和呈现的时候把经验分析，可能性拓展，分歧点以及易错点这些方面都详尽是我认为的至关重要的，也是一篇好文章的关键。但深度的提升意味着时间和精力的需求增加，这无疑是需要权衡的，好的文章很可能需要花费许多的时间和经历，这也是我很钦佩一些尽大佬的原因。对于自己来说，这方面可能还有待提升，受到工作上业务增加的限制以及生活上也有其他安排，如何去呈现更好的内容可能是接下来需要考虑的。</li></ul><p>回看自己的计划，还有部分想要研究和呈现的内容没有实现，也许不得不接受自己预期的内容和实际上的结果受到客观或者主观因素的影响导致不一致的情况是常态这件事。</p><p>黑暗中，前人制作并手持提灯找着路，留下余光指引后来之人，后来之人则留下标记给再后来之人。非常感谢所有愿意分享知识的大佬。</p><h2 id="搬家"><a href="#搬家" class="headerlink" title="搬家"></a>搬家</h2><p>今年先后搬过两次家，一次是到一个老年人很多的小区里面，里面的老年人会做很多本地相关的习俗像是请道士作法游走，烧各种纸，聚集起来念经之类的，而像是早上会敲锣打鼓之类的就很烦，不过小区整体环境还不错，各种设施都有，相比23年短租用来临时落脚的小房间要大一些，有20多平，厕所在房间外面，缺点就是房租偏贵。这是我第一次住二房东的房子，后面租期未到因为二房东和大房东的冲突不得不走，这家伙即使租大房东的房子快到期了，还在劝其他租客入住，临近期限让我们租客交钱给她，直到大房东找上门一个个敲租客门来说明才了解到情况，所以情况就成了 二房东租大房东房子到期了，大房东要撵人因为她已经打印要租给其他人了，如果二房东不走大房东就要赔违约金，大房东就要告二房东，所以希望这种情况发生之前让二房东告诉租客让租客走，我们租客和二房东有合同，而二房东想要敛财，没告诉我们租客，导致大房东临近交接日亲自上门找我们租客告诉我们情况，而我们租客也不得不走，因此这次住房以这种形式结束。不过后面我们同一楼层的租客在一位大哥的带领下联合起来一起给二房东上压力要求退钱和赔偿，让二房东之前吞下去的钱全部吐了回来，好不痛快！至于赔偿这东西要很多时间去处理，大伙还要在很短时间找下家搬出去且几乎都是打工人，因此最终还是在拿回钱和争取到足够的搬家时间后，没有去追究了。</p><p>第二次搬家是到了一所公寓，公司上同事推荐的，实际上也确实不错，除了电价偏高之外没有什么好挑剔的，房间也相比之前大了一下，由于毕业两年内大学生的补贴，最终价格也能接受。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>今年给我印象最深的游戏有两款，首先就是《黑神话悟空》，也是中国的第一款真正意义上的3A，中国IGN给了10&#x2F;10，游民的评测文案写的让人感动无比，而国外IGN却给了8&#x2F;10。因为上班时间有限，为了能在最短的时候体验完游戏的内容，伴随着游民中的玩家提供的地图让我在一周目就实现了全收集，花费46小时，实现了64&#x2F;81的成就。初步通关的时候，我觉得国外的8&#x2F;10是合理的，因为游戏中许多让人因为非游戏性难受的地方（就是经典的空气墙和引导差，部分地方大而空那一套），虽然最终这在某些层面上可以被视作小问题，但实际游玩的时候那一套问题和想要探尽隐藏区域的想法冲突导致的挫败感还是挺强的，如果没有游民的地图，相信这个体验会更加糟糕。但除此之外，整个游戏带给我的惊喜感数不胜数，我现在仍然能回忆起公司里面不少人中午午休的时候很多人都在自己电脑上玩，然后交流和比赛打BOSS的快感以及观看剧情解析深入了解游戏剧情后恍然大悟和不断思考回顾的愉悦，而之后看见越来越多的打法，越来越多人展示精湛的操作，又好不让人拍手称绝！即使后面没有玩二周目，看见其他人对于游戏的深度探究和各个层面的解析，到这个时候，我才能理解10&#x2F;10的理由—————它注定不是完美的，开发者也表示有很多问题，但是它带来的这段美妙的体验让它配的上10&#x2F;10的评价。<br>这也使得最终TGA给了小机器人，不是黑神话悟空的时候，觉得相当遗憾以及滑稽。<br><img src="/img/wukong.png" class="post-image" /></p><p>除此之外还有一块便是 《动物井》，它是一个独立开发者开发耗时近7年的游戏，大小只有33mb，但却富含了无数的玩法，众多有趣的谜题和超大（不开玩笑）的体量。每一步都让我的好奇心逐渐增长，每一次解密都让我的期待心和成就感愈发强烈，我享受其带给我的每一分钟，然而就在我初步通关后，同事莫名高深的告诉我，说我游戏的内容探索甚至不到10%,后面看了攻略和解说才醍醐灌顶。这是增加了我对游戏认知的一款游戏，多年以后我还能回忆起的游戏里面绝对会有动物井的一席之地。</p><img src="/img/animalwell.png" class="post-image" /><h2 id="动画与漫画"><a href="#动画与漫画" class="headerlink" title="动画与漫画"></a>动画与漫画</h2><p>我初步认识藤本树并不是电锯人，而是通过电影版的《蓦然回首》。这部动画就像是打开了我新世界的大门一样，它带给了我全年里最棒的一次影院体验，让我认识到了藤本树这位漫画家，让我继而去看了再见绘梨，炎拳，买了其他短片并去看了漫画版的电锯人，并被深深吸引。有一句话比较符合我对他作品的感受————“在一个带有奇幻色彩的世界观，加一个角色本位的视角，试图展示人类情感的美好之处”。</p><p>此外，蓦然回首是我见过原名称比中文要好的一个典范，原名叫做look back ，个人理解它可以有3层含义</p><ol><li>藤本树对于自己过往的一个回忆。</li><li>剧中京本对于藤野的一个回忆。</li><li>剧中藤野是看着京本的“后背”成长的，因此叫做look back 意义为“跟在你后面”成长，这也和藤野想要离开京本独自学习的主题相关。</li></ol><p>而中文只能表达前两层，而损失了第三层意思。</p><p>作为一名游戏开发者，自己多多少少怀揣一颗创作者的心，我想这也是蓦然回首打动我的原因之一，因为它本身就是一首对于创作者的赞歌。看见好看的原画，精心创作的视频，好玩且富含细节的游戏的时候会心中不止的荡漾起来，这让我不禁期待，希望自己能给能让自己心中充满热情的游戏效力。</p><img src="/img/lookback2.jpg" class="post-image" /><h2 id="装机"><a href="#装机" class="headerlink" title="装机"></a>装机</h2><p>今天初步尝试了自己装第一台海景房主机和DIY装饰设计。</p><img src="/img/pc.png" class="post-image" /><img src="/img/pc2.jpg" class="post-image" /><h2 id="猫"><a href="#猫" class="headerlink" title="猫"></a>猫</h2><p>今年5月4号从别人那里领养了一只1个月大的小猫，据说是3月28号出生的。给它取名交“板载”，为什么？ 因为当时随口问朋友，他就这样脱口而出了：“板载~”，毕竟当时在玩战地5，我一想有意思，好记，而且相当也许和这个孽畜相遇本身就是一件很“板载”（万岁）的事情，所以就这么取名了。<br>有意思的是，取名的朋友前不久也养了一只，征集名字的时候，反手就给他了一个“大伊万”(一种氢弹，游戏中用于代指游戏里面的队长叫的导弹)，不知道会不会采用(doge)</p><img src="/img/banzai1.png" class="post-image" /><img src="/img/banzai2.png" class="post-image" /><p>看着它一点点长大还是很快乐，虽然这个孽畜喜欢犯贱，但还是希望它健健康康的。</p><h2 id="展望与计划"><a href="#展望与计划" class="headerlink" title="展望与计划"></a>展望与计划</h2><ol><li>进一步提升下技术。还有很多想做但还没做的。</li><li>培养一个兴趣。当然，这需要资金和时间上的支持，根据情况来吧。</li><li>多存一点钱吧。今年装机和搞桌面设计花了一笔额外的钱，其他类似，没有达到预期的值。投资的效益也没有预想的高，应当重新制定下计划。</li><li>保持身体健康。减少熬夜吧，还是要有即使怀有遗憾也能结束一天的勇气。</li><li>希望能恢复健身的习惯。今年后面健身都是断断续续的，重新根据情况指定下计划吧。明年希望能做的更好。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI基础理论和性能优化</title>
      <link href="/2024/12/22/ugui/"/>
      <url>/2024/12/22/ugui/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里将从讨论UGUI的基础理论，并从中得到可能影响性能的因素并针对这些因素进行优化这三个方面展开。</p><h2 id="UGUI基础"><a href="#UGUI基础" class="headerlink" title="UGUI基础"></a>UGUI基础</h2><p>这里将讲述简单说明几个基础知识要点。核心内容来自Unity官方文档，翻译参考了花卷。</p><h3 id="Canvas基本功能逻辑"><a href="#Canvas基本功能逻辑" class="headerlink" title="Canvas基本功能逻辑"></a>Canvas基本功能逻辑</h3><ol><li>Canvas被Unity渲染系统用于渲染几何体在游戏世界空间中。负责把它包含的Mesh(网格)合成批处理(合批)，生成适当的渲染命令(Draw Call)并将它们发送到 Unity 的图形系统。这个过程称为ReBatch(重建批次)或者Batch Build(批处理构建)。<br>当前Canvas被标记为包含<b>需要Rebatch的几何体</b>时候，该Canvas会被标记为Dirty。</li><li>Canvas中几何体数据的通过Canvas Renderer组件进行传递。</li><li>父Canvas和其子Canvas除了父Canvas的改变导致子Canvas的大小发生变化的情况，不同的Canvas之间是互不影响的。</li></ol><h3 id="Graphic基本功能逻辑"><a href="#Graphic基本功能逻辑" class="headerlink" title="Graphic基本功能逻辑"></a>Graphic基本功能逻辑</h3><p>Graphic类是 Unity UI C# 库提供的基类(Base Class)。它是所有为 Canvas 系统提供可绘制几何图形的 Unity UI C# 类的基类。大多数内置 Unity UI Graphics 都是通过 MaskableGraphic 子类实现的，这允许它们通过IMaskable接口进行遮罩。<br>后面说的Graphiczyć就是指继承自Graphic类的组件(Graphic Components)</p><h3 id="Layout基本功能逻辑"><a href="#Layout基本功能逻辑" class="headerlink" title="Layout基本功能逻辑"></a>Layout基本功能逻辑</h3><p>Layout Component(布局组件) 仅依赖于 RectTransofrm，通过控制其属性，来实现错综复杂的布局。也因此它不依赖于Graphic类，可以独立于 Unity UI 的 Graphic 组件使用。<br>后面说的Layout便是Layout Component。</p><h3 id="CanvasUpdateRegistry"><a href="#CanvasUpdateRegistry" class="headerlink" title="CanvasUpdateRegistry"></a>CanvasUpdateRegistry</h3><p>Graphic 和 Layout 都依赖于CanvasUpdateRegistry类。该类会去跟踪必须更新的Graphic类和Layout组件，并在其关联的Canvas触发事件willRenderCanvases时进行更新。(这个事件每帧都会被调用一次)</p><p>Grahpic类和Layout组件的更新称为Rebuild(重建)，这里的Rebuild指的是重新计算Layout布局以及继承Graphic类的组件的网格数据。<br>在Canvas触发事件willRenderCanvases时，CanvasUpdateRegistry接收事件并执行方法PerformUpdate，此方法主要执行内容为：</p><ol><li>被标记为Dirty状态的Layout请求重建其布局(Rebuild)。</li><li>所有的已注册的裁剪组件(比如Masks) 会请求裁剪任何需要被裁剪的组件。</li><li>被标记为Dirty状态的继承Graphic类的组件请求重建其图形元素(Rebuild)。</li></ol><h3 id="渲染方式和细节-OverDraw和fill-rate填充率"><a href="#渲染方式和细节-OverDraw和fill-rate填充率" class="headerlink" title="渲染方式和细节(OverDraw和fill-rate填充率)"></a>渲染方式和细节(OverDraw和fill-rate填充率)</h3><p>渲染中，Canvas所绘制的几何体都在透明队列中，通过alpha blending从后往前进行绘制。值得注意的是从多边形栅格化的每一个像素都将被采样，即使当前像素点被其他不透明多边形完全覆盖。这种情况中，同一个像素在一帧中被重复绘制的次数叫做overdraw。而fill-rate(填充率)是指GPU的每秒可处理的像素数量。过高的OverDraw会迅速增加GPU的fill-rate。</p><h3 id="Batch-Build-Rebatch-过程-Canvas"><a href="#Batch-Build-Rebatch-过程-Canvas" class="headerlink" title="Batch Build(Rebatch)过程(Canvas)"></a>Batch Build(Rebatch)过程(Canvas)</h3><p>在Canvas组合其<b>代表UI元素的Mesh(网格)</b>合成批处理，生成适当的渲染命令并将它们发送到 Unity 的图形系统的这个过程中，需要对网格进行深度排序，并检查它们是否重叠，是否共享材质等，这个过程是通过多线程进行的，因此其性能受到不同CPU结构影响。</p><p>而此过程的结果会被缓存复用，直到Canvas中因为任意一个网格发生变化而被标记为Dirty状态为止。</p><h3 id="Rebuid过程-Graphic"><a href="#Rebuid过程-Graphic" class="headerlink" title="Rebuid过程(Graphic)"></a>Rebuid过程(Graphic)</h3><p>为了重新计算包含一个或者多个Layout的组件的正确位置，就必须先按照适当的层级顺序去计算，因为Hierarchy中靠近根节点GameObject的Layout的修改很可能嵌套于其中的子物体的Layout位置和消息。所以越靠近根节点的Layout越优先被计算。<br>为此，UGUI会把被标记为Dirty状态的Layout按照它们在Hierarchy中的层级进行排序，层次结构较高的项，也就是父Transform较少的项，会被放在列表的前面，被优先计算。<br>之后，在CanvasUpdateRegistry的PerformUpdate方法中，这些被排序好的Layout会请求Rebuild(重建)它们的布局，这也是被Layout控制的UI元素真正改变位置和大小的过程。</p><h3 id="Rebuild过程-Layout"><a href="#Rebuild过程-Layout" class="headerlink" title="Rebuild过程(Layout)"></a>Rebuild过程(Layout)</h3><p>当Graphic进行Rebuild的时候，UGUI会把控制权交给实现ICanvasElement接口的Rebuild方法。在此Rebuild过程中，Graphic会执行两个不同的重建步骤：</p><ol><li>如果顶点数据已经被标记为Dirty状态，比如此组件的RectTransoform的大小发生变化的时候，那么就会重建网格数据。</li><li>如果材质数据已经被标记为Dirty状态，比如此组件的材质或纹理发生变化的时候，那么就会更新附着在Canvas Renderer的材质数据。</li></ol><p>Graphic的Rebuild不需要按照特定的顺序进行，自然也不需要进行任何排序。</p><h3 id="合批"><a href="#合批" class="headerlink" title="合批"></a>合批</h3><p>类似于3D模型的批处理，UGUI的合批是一种优化手段，它通过把某个Canvas下面满足合批规则的UI控件的Mesh(网格)合并成一个大的网格，这些合并在一起的网格只会调用一次Draw Call，然后提交给GPU进行绘制。<br>这种方式的目的便是为了减少Draw Call的数量，提高渲染效率。因为在每执行一次Draw Call的过程中，都需要CPU先执行准备数据并加载到显存，设置渲染状态信息这两个步骤，而这两步相当耗时间！因此如果Draw Call的数量过多，那么CPU就会把大量的时间花在准备数据和设置渲染状态上，从而造成性能问题。<br>值得一提的是，合批的操作是在子线程完成的。</p><h4 id="合批规则"><a href="#合批规则" class="headerlink" title="合批规则"></a>合批规则</h4><p>UI控件之间的合批是有条件的。</p><ul><li>合批范围：合批以Canvas为单位，不同的Canvas之间的控件无法进行合批以及透明度和长宽为0以及active为false的Canvas也无法进行合批。</li><li>基本条件：拥有完全相同的贴图和材质球(Shader)。</li><li>Depth计算：确定Canvas下各个UI控件的深度值Depth。</li></ul><h4 id="Depth计算规则"><a href="#Depth计算规则" class="headerlink" title="Depth计算规则"></a>Depth计算规则</h4><p>从Hierachy中从上网一下依次遍历Canvas中的所有元素，对于当前UI元素。</p><ol><li>如果当前元素不参与渲染，则Depth为-1。</li><li>当前元素下面没有与其他要渲染的UI相交，则Depth为0。</li><li>当前UI下面有且只有一个UI元素与其相交，且两者材质和贴图完全一致，则两者Depth相同，否则上面的是下面的Depth+1。</li><li>当前UI下面有多个UI元素与其相交，按照步骤3计算出当前UI下面每个元素的Depth，得到最高的MaxDepth，则当前UI的Depth就为DepthMax。</li></ol><p>这里的相交指的是两个UI元素之间的Mesh网格有重叠部分，而不是RectTransform的区域有重叠。</p><h4 id="合批过程"><a href="#合批过程" class="headerlink" title="合批过程"></a>合批过程</h4><p>建立在Depth计算完成的基础上。</p><ol><li>按照 Depth，Material ID，Texture ID，RendererOrder(即Hierarchy面板上的顺序) 的优先级(从大到小)进行排序。然后剔除Depth为-1的元素。得到Batch前的UI元素队列，这个队列被称之为VisiableList。</li><li>判断VisiableList中相邻的元素之间的材质和贴图是否完全一致，如果一致就能够进行合批，这与Depth是否相同无关。最终一个又一个批次地合并成对应的网格，提交给GPU进行绘制。</li></ol><p>在了解了这一点后，就能理解为什么一个Canvas中任意一个元素的材质，网格顶点，位置，颜色或者在Canvas下面动态创建或者删除UI元素等都将导致该Canvas重新计算合批去生成新的网格了，毕竟任意一个网格的变化都有可能影响到最终合批的结果。<br>而网格发生变化的话就需要重新计算生成新的网格，这个过程就是上面所说的ReBuild，这也是说Rebuild后会引起Canvas的batch build的原因。</p><p>特别要注意的一点是，postion.z不为0的UI元素视为3D UI，其子物体全部不参与合批，且打断前后合批。</p><h2 id="影响性能的因素和优化"><a href="#影响性能的因素和优化" class="headerlink" title="影响性能的因素和优化"></a>影响性能的因素和优化</h2><p>想必通过上面的介绍，脑中应该可以构建出一个大致的模型图。通过这个模型图，我们可以联想到几个可能影响性能的地方：</p><ul><li>GPU片段着色器利用率过高。也就是过高的OverDraw导致GPU的fill-rate(填充率)容量不足。</li><li>Canvas的batch build花费过多的CPU时间。这里面同样包含合批批次太多，产生了过多的Draw Call。</li><li>Canvas的batch build过于频繁。</li></ul><p>以及官方提供的生成顶点(通常来自文本)花费CPU过多时间。</p><p>原则上，创建一个UGUI其性能是受到发送给GPU的draw calls的数量(也就是合批的数量)的所限制的。但实际中，任何使得GPU超载的项目中，比起draw calls的数量，更像是受到fill-rate的限制。</p><p>因此，接下来就只需要搞清楚哪些行为导致了这些问题的发生，然后针对性的进行优化即可。</p><h3 id="引起Canvas的batch-build过于频繁的因素"><a href="#引起Canvas的batch-build过于频繁的因素" class="headerlink" title="引起Canvas的batch build过于频繁的因素"></a>引起Canvas的batch build过于频繁的因素</h3><p>Canvas中会因为任意一个Mesh(网格)发生变化就会被标记为Dirty，并进行batch build。过多的Mesh变动会导致Canvas频繁的batch build，因此为了减少batch build的次数，就需要尽量减少Canvas中Mesh改变的次数。<br>这一点可以从两个方面进行理解：</p><ol><li>减少对Canvas中UI元素的改动。但实际上UI的改动多是根据需求进行的，如果需求需要的话，这些改动是无法避免的。</li><li>修改进行“改动”的方式，使用不会触发Mesh发生变化的改动方式。比如使用CanvasGroup.alpha来修改透明度控制UI的显示和隐藏来替代使用SetActive，两种方式都可以实现效果，但前者不会触发Mesh的改变，而SetActive则会。</li></ol><p>类似SetActive会导致Mesh发生改变的条件有:</p><ul><li>Transform的属性变化</li><li>Text文本内容发生变化</li><li>Graphic的Color属性发生变化</li><li>UI组件的添加和移除</li><li>Image内容发生变化</li></ul><p>除了上面举例的这些，先看一下会触发Rebuild的条件有：</p><ul><li>Layout修改了RectTransform的影响布局的属性</li><li>Graphic的Mesh或者Material发生了变化</li><li>Mask裁剪的内容发生了变化</li></ul><p>Rebuild通常引起Canvas的batch build。</p><h4 id="rebatch过于频繁优化方式"><a href="#rebatch过于频繁优化方式" class="headerlink" title="rebatch过于频繁优化方式"></a>rebatch过于频繁优化方式</h4><p>这一部分的优化主要从第二点进行——尽量实现UI控件改动的同时不出发Mesh的改变。</p><ul><li>使用CanvasGroup.alpha来修改透明度控制UI的显示和隐藏。</li><li>通过Material来修改颜色而不是color属性。当前，前者会增加draw call 后者会导致Mesh改变引起Rebuild。这个需要根据实际进行权衡。</li></ul><h3 id="引起Canvas的batch-build时间过长的因素"><a href="#引起Canvas的batch-build时间过长的因素" class="headerlink" title="引起Canvas的batch build时间过长的因素"></a>引起Canvas的batch build时间过长的因素</h3><ol><li>UI元素数目过多且层次结构过于复杂，导致一次合批排序和分析计算的消耗过大。</li><li>产生了过多或者说冗余的Draw Call。比如：<ul><li>使用不当的UI组件。比如能通过Mask2D来实现的效果，使用了Mask组件，这就需要至少2个Draw Call。</li><li>一个页面中使用了太多的不同的材质球或者纹理等，导致无法合批，从而产生额外的Draw Call。</li></ul></li></ol><p>优化这一部分可以通过上面两个方面入手。</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>这个手段目的是减少合批排序和分析计算的消耗，但根据情况，可能会产生额外的Draw Call，因此需要权衡。</p><p>上面已经多次说过了，一个Canvas里面任何可绘制的UI元素网格发生变化的时候，Canvas都必须重新进行batch build，去重新分析和排序其包含的每个UI元素无论它们是否发生了变化。我们注意到即使一些UI元素长年不动或者说相对静止，也会被卷入到batch build的计算中，再考虑到各个Canvas之间的batch build是互不影响的，因此我们可以得到动静分离的优化手段————把经常需要发生变化的UI元素这一动态部分放在一个Canvas里面，把相对静止的静态部分放入另一个Canvas里面，从而实现静态部分不会因为动态部分的改变而收到“牵连”，进而实现性能优化。</p><p>这里的优化方式便是优化Canvas一次batch build的耗时，但实际上我们根据子Canvas或者同级Canvas进行分割的时候，因为Canvas并不会跨越单独的Canvas进行合批，收到位置和层级的影响的时候，便有可能会导致额外的Draw Call。这也是为什么开头就说要权衡的原因。</p><p>这在实际开发中不一定好控制，除了这一点之外，还有一个要点就是Unity 5.2优化了批处理代码，显著提高了性能。UGUI在一个核心以上的设备上，会把大部分批处理放在子线程进行计算，从而缓解主线程的压力。动静分离可能也因此收到的关注并没有那么高了。至少在本人目前的经历中，还没有采用这种形式的项目。</p><h4 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h4><p>这是用于减少Draw Call的手段。</p><p>前面已经说到了，合批需要有相同的材质和贴图，而我们通过把多个图片合在同一张贴图上面，便可以让使用这些图片的UI元素共享同一张贴图，从而在材质相同的情况就可以进行合批，从而减少Draw Call。</p><p>打图集的规则：</p><ol><li>过大的图尽量不要打进图集里面，而是按照Texture的形式进行使用，一般为512以下的图片才允许进入图集。</li><li>通用的图片放在一个通用图集里面。</li><li>尽量把同一个页面，同一个功能的图放在一个图集里面。</li><li>不要把重复的图打到不同的图集里面。</li></ol><h3 id="引起GPU的fill-rate过高的因素"><a href="#引起GPU的fill-rate过高的因素" class="headerlink" title="引起GPU的fill-rate过高的因素"></a>引起GPU的fill-rate过高的因素</h3><p>在前面渲染细节中已经讲过overdraw和fill-rate的概念，这里不再赘述。此外，Unity可以在Scene试图切换Overdraw模式，查看填充率情况。</p><p>fill-rate过高的情况通常是由于大量的重叠UI元素或者屏幕包含了过多的UI元素导致的，因为这两种情况都会造成过多的Overdraw。</p><p>可以采取两种方式来减轻GPU的渲染压力：</p><ol><li>减少必须采样的像素数量。</li><li>降低片段着色器的复杂性(fragment shaders)。</li></ol><p>这里主要围绕第一种方式来讲。优化方式主要可以分为如下几点：</p><ol><li>关闭玩家看不到的UI元素。让UI元素被完全覆盖的时候，最理想的情况就是让它不参与渲染，比如把它回收关闭或者隐藏。比如我们可能永远只允许一个全屏页面显示在屏幕上，此全屏页面上只允许类似弹窗性质的UI元素显示。</li><li>关闭不可见的相机输出。比如我们渲染3D场景的相机和我们渲染UI的相机在不相同的情况，当我们打开的页面完全覆盖了原本的3D场景，就可以关闭完全被遮挡的摄像机，从而减少GPU需要渲染的工作量。而如果没有完全覆盖，则根据情况可以选择将场景渲染为texture(纹理)并使用，而不是让它连续进行渲染。</li><li>需要相应Raycast事件时，不要使用空的Image，可以自定义组件继承自MaskableGraphic，重写OnPopluateMesh，并把Mesh清空，这样可以响应Raycast又不需要绘制Mesh。</li><li>慎用Mask组件和Outline，Shadow组件。</li></ol><p>除此之外，还有许多地方可以优化，这里就不一一列举了。<br>如若有误，欢迎指正。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://learn.unity.com/tutorial/optimizing-unity-ui#5c7f8528edbc2a002053b5a3">UGUI优化官方文档</a></li><li><a href="https://www.drflower.top/posts/aad79bf1/">花卷的UGUI优化总结</a></li><li><a href="https://blog.csdn.net/sinat_25415095/article/details/112388638">WangShade的合批详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
            <tag> UI </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework解析：资源(Resource)</title>
      <link href="/2024/11/24/gf_resource/"/>
      <url>/2024/11/24/gf_resource/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>资源这个模块有太多太多的东西，一开始我也想过把这个模块完完整整的去做一下详解，把每一个小模块都拿出来说一下，但这玩意要写的话，能说的地方和能讲的拓展实在太多了，以及伴随着工作上事情的越来越多，这个文章应该会逐步采用逐步更新的方式。</p><p>先来看一下GF官方的说明：</p><blockquote><p>为了保证玩家的体验，我们不推荐再使用同步的方式加载资源，由于 Game Framework 自身使用了一套完整的异步加载资源体系，因此只提供了异步加载资源的接口。不论简单的数据表、本地化字典，还是复杂的实体、场景、界面，我们都将使用异步加载。同时，Game Framework 提供了默认的内存管理策略（当然，你也可以定义自己的内存管理策略）。多数情况下，在使用 GameObject 的过程中，你甚至可以不需要自行进行 Instantiate 或者是 Destroy 操作。</p></blockquote><h2 id="打包方式和出包形式"><a href="#打包方式和出包形式" class="headerlink" title="打包方式和出包形式"></a>打包方式和出包形式</h2><p>先简单说一下通过ResourceEditor进行分包以及使用ResouceBuilder进行出包。以及这两个工具的使用方式和详细参数含义，可以参考官方文档和烟雨的文档，贴在了参考文档里面，方便自行查阅，这里就不浪费时间了。</p><p>打包菜单栏在GameFramework下的ResourceTools选项中。<br><img src="/img/gf_checkResourceTool.png" class="post-image" /></p><p>ResourceEditor:<br><img src="/img/gf_resourceEditor.png" class="post-image" /><br>如果你用的是官方的StarForce项目，那么打开就能看到已经分好的资源列表。这根据是否配置了FileSystem，对于配置了FileSystem的资源，最终在Package中会被整合在对应的包中，添加ResourceGroup参数则是进行会资源分组，如Base、Music。<br>对应数据的显示和配置都在ResourceCollection.xml文件里面。</p><p>这里以StarForce项目举例说明，通过ResourceBuilder打包，在Full文件夹下面可以看见所有已经被打好的包：<br><img src="/img/gf_resource_fullpackages.png" class="post-image" /></p><p>在Package文件则可以看到分好类后的包，这里的分类是根据FileSystem来的<br><img src="/img/gf_resource_pacakageResource.png" class="post-image" /></p><img src="/img/gf_resource_resourceCollection.png" class="post-image" />通过Editor打包页面和ResourceCollection.xml里面的详细信息我们可以得出：<ul><li>资源文件总数为128；</li><li>资源列表数量为21个，总共分成了21个资源包；</li><li>FileSystem总共有3个，分别是GameData，Resources以及UI，最终对应着Package文件夹下3个包;</li><li>ResourceGroups总共有2个，分别为base和Music。</li></ul><p>其他的环境配置和使用方式网上有很多资料说明，如果有需要可以在通过参考文档里面的链接进行自行查找。<br>初次使用的话，注意几个点就行：</p><ol><li><p>关于BuildInfo里面CheckVersionUrl的地址，在请求的时候会自动加上平台信息，没加的话路径就会出错。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProcedureCheckVersion.cs</span><br><span class="line"></span><br><span class="line">GameEntry.WebRequest.AddWebRequest(Utility.Text.Format(GameEntry.BuiltinData.BuildInfo.CheckVersionUrl, GetPlatformPath()), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li><li><p>在单机模式使用Package文件夹里面的资源即可，但是在可更新模式里面，要上传的是Full文件夹里面的资源。</p></li><li><p>别忘了把流程中的校检流程给勾选上</p><img src="/img/gf_resource_verifyProcedure.png" class="post-image" /></li></ol><h2 id="资源模式"><a href="#资源模式" class="headerlink" title="资源模式"></a>资源模式</h2><p>GF的资源模式有四种，编辑器模式，单机模式，预加载的可更新模式以及边玩边下的更新模式。</p><h3 id="编辑器模式"><a href="#编辑器模式" class="headerlink" title="编辑器模式"></a>编辑器模式</h3><blockquote><p>在 Unity 编辑器中，可以考虑使用 Game Framework 提供的编辑器模式，直接从磁盘进行资源加载，而避免每次修改资源都要重新构建 AssetBundle，以提高开发效率。<br>当然，即使在 Unity 编辑器中，依然可以手动关闭编辑器模式，从 AssetBundle 加载资源，以模拟和真实运行环境一样的效果。</p></blockquote><p>编辑器模式并不需要去获取资源包，资源的加载逻辑位于EditorResourceComponent中，资源加载的形式是AssetDatabase，同时通过随机数延迟加载时间模拟异步加载的效果。</p><p>综上，编辑器模式在流程初始化的时候并不会做相关资源处理，在流程ProcedureSplash中，检测到如果是编辑器模式便会直接来到ProcedurePreload。</p><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>此模式游戏流程中资源的初始化：<br><img src="/img/gr_resource_process_package.png" class="post-image" /></p><p>单机模式并不需要对比版本信息，只需要根据当前版本信息从资源包里面加载对应的资源到内存中，并让它们接受管理。</p><ul><li>从进程中的ProcedureSplash开始，不同于上面的编辑器模式直接进入Preload,单机模式需要先初始化资源，因此需要先进入ProcedureInitResources中。</li><li>从此处开始通过ResourceComponent的逻辑执行GF层里面ResourceManager中ResourceIniter的功能进行资源的初始化。</li><li>ResourceIniter里面会加载版本信息，也就是放置于StreamingAssets下的GameFrameworkVersion.dat文件，而这部分的详细逻辑来到了ResouceHelper里面，这里便是DefaultResourceHelper里面的LoadBytes，获取相关的资源的二进制格式数据流。</li><li>通过单机模式的资源列表序列化器，从指定流中反序列化数据，通过数据头标识进行检查，在通过对应的资版本资源列表回调函数去执行对应的数据流，由此开始存入对应的版本信息，资源信息，资源组，文件系统等并在之后想对应的数据存入到ResourceManager的m_InternalResourceVersion，m_AssetInfos，m_ResourceInfos以及m_ResourceGroups等容器中，提供给全局。<br>m_AssetInfos对应便是资源文件总数，参考上面也就是128个。<br>m_ResourceInfos对应的便是资源列表数量，参考上面也就是21个，这种模式下资源包的准备情况(m_Ready)都是true，同样资源也都只在只读区。<br>m_ResourceGroups对应便是资源组数量，参考上面也就是2个。<br>以及这里资源列表回调函数是通过ResouceComponent里面手动注册的，包含0,1,2三种version，这是根据打包的具体情况自动决定的，无需额外操作。</li><li>等上面的一切都完成了，才会触发最初的回调，流程开始进入Preload中。</li></ul><h3 id="预加载更新模式"><a href="#预加载更新模式" class="headerlink" title="预加载更新模式"></a>预加载更新模式</h3><p>流程<br><img src="/img/gf_resource_process_updateMode.png" class="post-image" /></p><ul><li>对比版本信息，判断是否需要进行更新。在CheckVersion流程中向服务器请求版本信息的时候，也就是GameEntry.WebRequest.AddWebRequset这一步，GF里面加了平台的判断，在命名文件以及书写buildinfo的时候应当注意进行对应修改。版本信息拿到后，主要判断：<ul><li>是否需要强制更新游戏应用，也就是重新通过链接去下载客户端。</li><li>是否需要更新资源。这是通过对比本地版本文件信息(GameFrameworkVersion.dat)和远程信息文件的版本号是否相同来进行判断的。<br>如果需要的话，就会进入UpdateVersion流程去更新版本信息，如果不需要则可以直接进行资源的校检流程VerifyResources。<br>ResourceManager里面将版本检测更新等逻辑整合在了VersionListProcessor这个内部类里面。</li></ul></li><li>更新版本信息文件。来到UpdateVersionList这一步首先会去下载远程的GameFrameworkVersion.dat,在确定好当前下载完成后的信息和之前获取的远程版本信息一致后，进行解压，并将解压后的数据写入到文件流中，从而实现本地版本信息文件的更新。</li><li>获取本地的资源，进行资源的校检。来到VerifyResources流程，到这一步会去获取本地的GameFrameWorkList.dat文件，如果能获取到的话，就会直接通过资源列表序列化器(ReadWriteVersionListSerializer)获得版本列表信息，然后解析后存于本地并进行校检，检查本地资源的完成性，如果有问题就会移除当前有问题的资源信息，并重新写一个资源列表文件到本地；如果不能获取到资源列表，则说明本地没有，直接进入CheckResources流程。<br>这里的逻辑封装到了ResouceMangaer的内部类ResourceVerifier中。</li><li>检查本地资源信息是否和远程的资源对的上。首先会获取三个信息，远程的资源版本信息GameFrameworkVersion.dat(经过前面，已更新到本地的读写区)，本地的读写区和只读区资源列表信息GameFrameworkList.dat(存在没有的情况)。通过远程的资源版本信息获取此版本应有的资源信息，解析后加入到ResouceMgr对应容器里面，这一点和单机模式一致，不过此时还会加入到m_CheckInfos里面，用于后面进行资源校检。当这三者都加载完成后，会进行资源状态的检查，确定每一个资源的状态，判断其存在位置，是否需要更新，是否需要移除等，最终根据状态去执行对应的操作，比如需要更新的话，就会放入资源更新器(ResourceUpdater)里面去进行更新。统计和执行完成后则会进入UpdateResouces流程。<br>这一步逻辑的封装在ResourceManager的内部类ResourceChecker中。</li><li>打开资源更新页面，开始更新资源。更新完成之后就进入到ProcedurePreload流程中了。更新详细逻辑封装在ResourceManager的内部类ResourceUpdater中。</li></ul><h3 id="边玩边下更新模式"><a href="#边玩边下更新模式" class="headerlink" title="边玩边下更新模式"></a>边玩边下更新模式</h3><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><h3 id="资源加载流程"><a href="#资源加载流程" class="headerlink" title="资源加载流程"></a>资源加载流程</h3><img src="/img/gf_resource_process_loadAsset.png" class="post-image" /><ul><li>加载的核心逻辑是封装到了ResourceLoader里面，ResourceManager里面各种重载的LoadAsset方法最终都会调用到ResourceLoader的LoadAsset方法。</li><li>CheckAsset，获取当前资源的信息和对应的依赖资源名称。此过程会依次获取AssetInfo以及ResourceInfo，这两者分别是从ResourceManager里面缓存的m_AssetInfos以及m_ResourceInfos里面进行获取的。AssetInfo里面存储的是当前资源的名称，依赖等基本信息，ResourceInfo里面则存储着更加详细的属性信息包括大小，加载方式以及当前资源的状态等。因此，我们检查状态的时候是通过ResourceInfo里面的Ready来进行判断的，而想要通过资源名字获取对应的ResourceInfo，则需要通过名称获取AssetInfo，再通过其字段ResourceName来筛选ResourceInfo，对于依赖资源信息则是通过AssetInfo里面的字段获取。</li><li>LoadDependencyAsset，加载依赖资源。如果当前资源有依赖资源，则会率先加载其依赖资源，当然如果依赖资源也有其依赖资源的话，仍会率先去进行加载，只有所有依赖资源加载完成后，才会加载当前资源。<br>这里问题来了，先前已经说过GF里面所有的资源加载都是异步的，这里当前资源和其依赖资源的加载都是异步，如何确保资源加载顺序？ 这里GF把具体的加载逻辑“外包”给了任务池模块。</li><li>如果当前的资源还没有“准备好”，那么就会放入资源更新器里面去进行更新状态。</li></ul><h3 id="任务池"><a href="#任务池" class="headerlink" title="任务池"></a>任务池</h3><p>任务池基础结构图<br><img src="/img/gf_taskPool_base.png" class="post-image" /><br>在资源模块中的应用的结构图<br><img src="/img/gf_resource_taskpool.png" class="post-image" /><br>通过结构图可以得知：</p><ul><li>TaskPool存在两个主要内容——Agent和Task。我们通过将Task添加进入TaskPool，然后由Agent去处理每一个Task，最终通过异步和回调的方式来实现资源的加载。</li><li>TaskPool中存储Agent的容器有两个——m_FreeAgent和m_WorkingAgent，顾名思义，m_FreeAgent是空闲的Agent，可以处理Task，而m_WorkingAgent里存储的便是正在处理Task的Agent。而存储Task的容器则只有一个m_WaitingTask，我们添加Task，便是添加到这个容器中，然后由Agent去处理Task。</li><li>Task有两种——LoadAssetTask和LoadDependencyAssetTask。这里我更倾向于将它们分别叫做主任务和子任务，当我们初步想要加载一个资源的时候，我们会创建一个主任务（LoadAssetTask），但这个时候不会立刻把它放进任务池里面，而是先去获取并加载其依赖资源，如果有依赖资源则会为其每个依赖资源创建子任务（dependencyAssetTask），并优先把子任务放进任务池里面，直到所有的依赖资源都添加进任务池，才会把主任务放进任务池。值得注意的是，依赖资源任务添加过程中，同样可能存在其依赖资源，因此子任务(LoadDependencyAssetTask)视情况也会成为其依赖资源加载的“主任务”，通过递归的方式来处理这种形式，就可以实现资源加载任务（Task）有条不絮的加入任务池里面。</li><li>加载和解析的逻辑位于Agent里面，而处理加载和解析的详细方式实现则是位于UGF层的Helper里面。这使得使用者可以根据实际项目情况去书写加载方式，而不修改GF层的结构。这里我们就以默认的DefaultLoadResourceAgent为例，来看看它是如何处理加载资源的。</li></ul><p>任务池任务加载流程：<br><img src="/img/gf_taskpool_process_running.png" class="post-image" /></p><p>ProcessWaitingTasks中status的四种状态对应的处理方式：<br><img src="/img/gf_taskPool_status.png" class="post-image" /></p><p>通过流程图可以更加直观的看到上述加载流程，而加载过程的进行时基于状态的判定，这里的话就是任务的状态，而这里任务的状态又对应着ResourceInfo里面的状态，<br>接着开始调查ResourceInfo的状态来源和管理器里面两个容器成员的来源吧</p><p>四种状态的含义：</p><ul><li>Done表示可以立刻完成此任务，这对应我们想要加载的资源(非场景)以及其依赖资源之前都被加载完成过，而当前资源被缓存到了对象池之中，我们直接拿出来用就可以。这种情况下，可以直接将agent从Working列表中移除，再把当前task从Waiting列表中移除，并进行释放。</li><li>CanResume表示可以继续处理当前任务，对应着两种情况<ol><li>虽然当前要在加载的资源之前未被使用过，但对应的包之前被加载过，可以直接从包里面异步加载此资源，只需要等待这个过程即可。</li><li>当前资源未被加载过，当前资源所在的资源包也没有被加载过，这就需要先把资源包加载出来，然后再去加载资源。<br>   这两种情况下，只能把task从Waiting列表中移除，当前agent还是处于Working列表中，不会释放任务。</li></ol></li><li>HasToWait表示不能继续处理此任务，需要等其他任务执行完成。这种情况对应着：<ol><li>当前资源包还没下载好，还在资源更新器里面进行处理；</li><li>当前资源正在加载中了，说明之前已经有agent处理过这个资源信息了，当前正在Working列表中；</li><li>当前资源依赖的资源还没加载完成，需要等待依赖资源加载完成；</li><li>当前资源的资源包还在加载中，对应的agent同样在Working列表中；<br>   这些个情况同样会把agent从Working列表中移除，但不会把task从Waiting列表中移除，也不会释放资task。</li></ol></li><li>UnknownError表示出现了未知错误，这是方便使用者根据可考虑到的意外情况进行特殊处理。这时候会完全把agent从Working列表中移除，把task从Waiting列表中移除，并释放资源。</li></ul><p>资源加载完成后，就可以通过Task里面的回调进行资源的传递和使用了。<br>同样，有问题欢迎指出。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a href="https://gameframework.cn/uncategorized/%e4%bd%bf%e7%94%a8-assetbundle-%e7%bc%96%e8%be%91%e5%99%a8/">官网_使用 AssetBundle 编辑工具</a></p></li><li><p><a href="https://gameframework.cn/uncategorized/%e4%bd%bf%e7%94%a8-assetbundle-%e7%bc%96%e8%be%91%e5%99%a8/">官网_使用 AssetBundle 构建工具</a></p></li><li><p><a href="https://blog.csdn.net/h824612113/article/details/124870294">打包和热更的环境配置和操作方式</a></p></li><li><p><a href="https://www.lfzxb.top/gameframework-reshotfix/">烟雨的资源热更新详解</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> GameFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GameFramework </tag>
            
            <tag> 资源 </tag>
            
            <tag> 热更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework解析：数据表(DataTable)</title>
      <link href="/2024/11/16/gf_dataTable/"/>
      <url>/2024/11/16/gf_dataTable/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾经听过这样一个故事，貌似在某个项目，某位程序大拿在项目中引入的导表工具不支持策划在Excel表中写入任何的中文，自然每张表中就没有策划任何的中文注释，程序的使用也是见招拆招，最终形成了一道天然的“防护壁垒”。最后拍拍屁股走人，可谓前人栽树后人遭殃，直到后面得遇高人，才使得配表这个功能幽而复明，回到正轨。<br>开个玩笑，让我们进入正题。<br>游戏开发中数据表是策划控制游戏各项功能实际运行的重要工具，是连接策划和程序的桥梁。它存储和管理者游戏中的各种数据，通过改表就可以对游戏中的各项数据和功能进行修改，提高了游戏设计和功能的可拓展性和灵活性。来看一下官方的定义：</p><blockquote><p>可以将游戏数据以表格（如 Microsoft Excel）的形式进行配置后，使用此模块使用这些数据表。数据表的格式是可以自定义的。</p></blockquote><h2 id="导表流程"><a href="#导表流程" class="headerlink" title="导表流程"></a>导表流程</h2><p>这里的导表可以分为两个阶段来说，一是生成数据表DR类，二是读取数据表里面的数据并提供给其他模块使用。</p><h3 id="生成数据表DR类"><a href="#生成数据表DR类" class="headerlink" title="生成数据表DR类"></a>生成数据表DR类</h3><img src="/img/gf_dataTable_process.png" class="post-image" />接下来就其几个流程进行单独的说明。<ul><li>GenerateDataTables：点击Unity自定义选项中的”Generate DataTables”按钮，就可以执行在DataTableGeneratorMenu类里面的GenerateDataTables方法。从这里开始执行导表逻辑。</li><li>GetDataTableNames: 获取所有需要导表的表名。这个环节在原作者的Star Force项目里面是通过在ProcedurePreload里面的静态字段进行定义的。当然也可以效仿花卷的塔防项目里面通过获取指定文件夹下面的所有txt文件并去掉后缀名来获取表名。</li><li>CreateDataTableProcessor: 遍历每个表，传入表名，创建一个DataTableProcessor实例，用来解析当前表里的各项数据。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataTableProcessor <span class="title">CreateDataTableProcessor</span>(<span class="params"><span class="built_in">string</span> dataTableName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataTableProcessor(Utility.Path.GetRegularPath(Path.Combine(DataTablePath, dataTableName + <span class="string">&quot;.txt&quot;</span>)), Encoding.GetEncoding(<span class="string">&quot;GB2312&quot;</span>), <span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过上面的代码传参值，最终其实对应的是指标的排版规则。对应着便是：<ul><li>nameRow &#x3D; 1 ,表示索引为1的行用于展示表的字段名称，注意不是表的名称，是表的字段名称。</li><li>typeRow &#x3D; 2,表示索引为2的行用于呈现表中各个字段的类型。</li><li>defaultValueRow &#x3D; null,表示不展示默认值。</li><li>commentRow &#x3D; 3，表示索引为3的行用于展示字段的注释。</li><li>contentStartRow &#x3D; 4,表示索引为4的行开始是表的正式内容。</li><li>idColumn &#x3D; 1，表示ID列的索引是1。</li></ul></li></ul><img src="/img/gf_dataTable_config.png" class="post-image" /><ul><li><p>GetDataProcessor: 针对表里的每个列字段类型，通过DataProcessorUtility获取对应的DataProcessor，用来解析当前列的数据。DataProcessorUtility的静态构造函数会在运行时自动加载好当前程序集中所有使用者定义的DataProcessor类型的实例，并通过它们GetTypeStrings方法返回的类型字符串属性进行索引，存储于字典中。<br>这里拿float类型举例。如果有一列的是数据类型是float类型，那么我们可以定义DataProcessor的派生类FloatProcessor,里面包含：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StarForce.Editor.DataTableTools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">DataTableProcessor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FloatProcessor</span> : <span class="title">GenericDataProcessor</span>&lt;<span class="title">float</span>&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> IsSystem</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> LanguageKeyword</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span>[] <span class="title">GetTypeStrings</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">string</span>[]</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;single&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;system.single&quot;</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">Parse</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">float</span>.Parse(<span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteToStream</span>(<span class="params">DataTableProcessor dataTableProcessor, BinaryWriter binaryWriter, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                binaryWriter.Write(Parse(<span class="keyword">value</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们只需要在配置表里面把对应的类型定义为GetTypeStrings里面包含的名称，然后通过此类型和传入的值就可以解析当前的列数据了。</p></li><li><p>CheckRawData: 通过正则表达式判断当前表中字段命名是否符合规范。</p></li><li><p>GenerateDataFile：创建每个表对应的二进制文件，并把数据对应写入。这也是为什么每一个对应的txt类型的表都有其对应的bytes类型的二进制文件。</p></li><li><p>GenerateCodeFile：创建每个表对应的代码文件，里面包含了对应的字段名称、类型、注释等信息，以及对应的解析方法。过程主要是通过每个表的类型和字段信息，去填补默认模版DataTableCodeTemplate.txt文件里面的内容。里面关于数据的解析方式区分系统和非系统，非系统或者不能直接转化的类型，都支持在DataTableExtension里面进行自定义解析和手动拓展。在生成数据表中每个字段的属性到DR类中后，会通过解析方法会根据传递的数据对本类的属性进行赋值。<br>这里还是用Entity表举例，生成的代码文件如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Game Framework</span></span><br><span class="line"><span class="comment">// Copyright © 2013-2021 Jiang Yin. All rights reserved.</span></span><br><span class="line"><span class="comment">// Homepage: https://gameframework.cn/</span></span><br><span class="line"><span class="comment">// Feedback: mailto:ellan@gameframework.cn</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 此文件由工具自动生成，请勿直接修改。</span></span><br><span class="line"><span class="comment">// 生成时间：2024-11-10 22:30:04.834</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> GameFramework;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityGameFramework.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StarForce</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 实体表。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DREntity</span> : <span class="title">DataRowBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> m_Id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取实体编号。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> Id</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_Id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取资源名称。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> AssetName</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">ParseDataRow</span>(<span class="params"><span class="built_in">string</span> dataRowString, <span class="built_in">object</span> userData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] columnStrings = dataRowString.Split(DataTableExtension.DataSplitSeparators);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; columnStrings.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                columnStrings[i] = columnStrings[i].Trim(DataTableExtension.DataTrimSeparators);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">            index++;</span><br><span class="line">            m_Id = <span class="built_in">int</span>.Parse(columnStrings[index++]);</span><br><span class="line">            index++;</span><br><span class="line">            AssetName = columnStrings[index++];</span><br><span class="line"></span><br><span class="line">            GeneratePropertyArray();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">ParseDataRow</span>(<span class="params"><span class="built_in">byte</span>[] dataRowBytes, <span class="built_in">int</span> startIndex, <span class="built_in">int</span> length, <span class="built_in">object</span> userData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (MemoryStream memoryStream = <span class="keyword">new</span> MemoryStream(dataRowBytes, startIndex, length, <span class="literal">false</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (BinaryReader binaryReader = <span class="keyword">new</span> BinaryReader(memoryStream, Encoding.UTF8))</span><br><span class="line">                &#123;</span><br><span class="line">                    m_Id = binaryReader.Read7BitEncodedInt32();</span><br><span class="line">                    AssetName = binaryReader.ReadString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GeneratePropertyArray();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GeneratePropertyArray</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>这里可以看到，到目前为止，针对每一个数据表都有其对应的二进制文件和DR类了，但不难注意到每个DR类里面的数据表示的应该是当前数据表一行的数据，而不是整个表的数据。因此，接下来就需要加载表里面的数据并进行存储，再提供给其他模块进行获取。</p><h3 id="表数据的加载"><a href="#表数据的加载" class="headerlink" title="表数据的加载"></a>表数据的加载</h3><p>从这里开始就是涉及到框架中DataTableManager的逻辑范围了。DataTable模块结构类似于全局配置（Config）模块，都是DataTableManager主要用于存储数据，模块的核心控制逻辑位于DataProvider，而DataTableHelper则是负责数据表数据的加载和解析具体逻辑。<br>一般我们都是通过二进制文件进行加载的，因为这样速度要快一些。</p><p>整体结构图：<br><img src="/img/gf_dataTable.png" class="post-image" /><br>从结构图可以看出，DataTableManager主要是维护着m_DataTables里面的数据，而DataProvider存在于每一个DataTable实例中。其实一个DataTable实例对应的便是一个数据表的数据，通过DataProvider来进行数据的加载和解析，而具体解析的方式通过DataTableHelper里面定义方法来进行实现。</p><p>这里以Star Force项目为例，展示表数据的加载流程：<br><img src="/img/gf_dataTable_process_readData.png" class="post-image" /><br>是不是觉得和全局配置里面加载配置文件数据的流程很相似？因为两者的核心加载逻辑都是位于DataProvider中的，通过赋予DataProvider不同的类型的数据持有者以及不同的Helper，就可以保持整体结构不变的情况下实现数据资源的加载，解析，存储的流程。<br>这里就其中的环节说明一下：</p><ul><li>ParseData：在DefaultTableHelper的这个环节，其实读取的还是对应数据表的数据，一行行地把当前的数据传递给对应的DataTable实例，然后在DataTable实例中，才是通过DR类里面的ParseDataRow方法去解析自己的数据，最后，把这里解析好的数据根据ID存入DataTable实例里面的m_DataSet字典中。</li></ul><p>完成上面的数据加载环节后，我们就可以调用DataTable模块，首先获取对应的类型的DataTable实例，然后通过ID获取对应的DR实例，从而获取到具体的数据了。<br>这里还是以Entity表举例，在EntityExtension里面我们可以看到ShowEntity方法中的使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDataTable&lt;DREntity&gt; dtEntity = GameEntry.DataTable.GetDataTable&lt;DREntity&gt;();</span><br><span class="line">DREntity drEntity = dtEntity.GetDataRow(data.TypeId);</span><br></pre></td></tr></table></figure><h2 id="几个值得注意的点"><a href="#几个值得注意的点" class="headerlink" title="几个值得注意的点"></a>几个值得注意的点</h2><p>整个模块整体的结构和逻辑其实和全局配置模块很相似，故不再一一整理说明，这里就几个值得注意的点进行说明。</p><h3 id="关于数据类型的解析"><a href="#关于数据类型的解析" class="headerlink" title="关于数据类型的解析"></a>关于数据类型的解析</h3><p>如果当前提供的数据类型不满足需求，则需要自己手动添加，并添加其对应的解析Processor以及在DataTableExtension中新增对应的解析方法，</p><h3 id="TypeNamePair"><a href="#TypeNamePair" class="headerlink" title="TypeNamePair"></a>TypeNamePair</h3><p>在DataTableManager里面，对于DataTable的存储是用字典的形式进行的，而字典的键的类型则是TypeNamePair，这也是GF的基础拓展写法之一。它是一个结构体，通过将类型和名称进行组合，在框架中经常被用作键进行使用，这样做不仅可以确保唯一性，还支持对于键进行进一步的细化拓展。</p><h3 id="关于导表工具"><a href="#关于导表工具" class="headerlink" title="关于导表工具"></a>关于导表工具</h3><p>整个流程中可以看到都是通过txt文件或者二进制文件提供数据的。而txt表的来源是需要外部导入到项目中去的，比如先通过Excel进行表格设计，然后导出为txt文件，再导入到项目中。这样的做法虽然简单，但也有很多不便之处，比如修改和拓展表的话，就需要重新导入文件，重新走一遍Excel导出以制表符分割的txt文件，然后修改编码格式的流程，如果直接在txt文件上面进行修改的话，很可能把格式弄错，导致数据解析错误，但本人目前没有发现GF里面有提供Execl导表工具，所以目前只能下这样的总结。</p><h3 id="关于拓展性"><a href="#关于拓展性" class="headerlink" title="关于拓展性"></a>关于拓展性</h3><p>关于数据表的使用，其实还有很多地方可以拓展，比如枚举的一键生成或者再进一步进行封装等等都是可以的。有兴趣的可以参考花卷的TowerDefense项目里面对应的Data模块，这里就不赘述了。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://blog.csdn.net/qq_37619255/article/details/129829566">哈哈的模块使用说明</a></li><li><a href="https://www.drflower.top/posts/6ca825f5/">花卷的塔防项目</a></li><li><a href="https://www.bilibili.com/video/BV1sE411C7cu">烟雨的视频演示</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GameFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> GameFramework </tag>
            
            <tag> 数据表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework解析：全局配置(Config)</title>
      <link href="/2024/11/06/gf_config/"/>
      <url>/2024/11/06/gf_config/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先要明白的一点是GF里面的全局配置并不是指的一般意义上的数据表，全局配置表的格式不能随便自定义，它的格式必须与当前的ConfigHelper里面写定的解析格式保持一致，否则无法解析。而它是用来存储一些全局性质的只读配置，如玩家初始速度、游戏初始音量等。</p><h2 id="全局配置模块结构图"><a href="#全局配置模块结构图" class="headerlink" title="全局配置模块结构图"></a>全局配置模块结构图</h2><img src="/img/gf_config.png" class="post-image" />从结构上就可以看出几个点：<ul><li>ConfigManager和DataProvider存在许多个相同的接口，是因为ConfigManager主要是对DataProvider里面的方法进行封装，模块的核心逻辑位于DataProvider。</li><li>DataProvider和DefaultConfigHelper的核心功能方法名称相同，是因为真正的对配置文件的读取，解析功能位于DefaultConfigHelper。</li></ul><p>这样做的好处是不仅实现了解耦，而且方便功能的修改和拓展，ConfigManager存储解析好的配置数据，并提供给外界功能接口；模块核心逻辑位于DataProvider；读取和解析的逻辑位于ConfigHelper。使用者可以使用默认的DefaultConfigHelper来加载对应格式的配置文件，也可以根据自己项目的需求，去书写自己的ConfigHelper来实现自定义的配置格式和对应的解析逻辑。</p><h2 id="读取解析存储全局配置流程"><a href="#读取解析存储全局配置流程" class="headerlink" title="读取解析存储全局配置流程"></a>读取解析存储全局配置流程</h2><img src="/img/gf_config_process.png" class="post-image" />整个流程为：读取————>解析————>存储。根据资源的名称，读取相对应的文件，然后根据定义的解析规则，解析成对应的配置数据，最后存储到ConfigManager里面。其中也支持二进制文件，并设置了相对应的缓存步骤对此格式的配置文件进行处理。<h2 id="ConfigManager"><a href="#ConfigManager" class="headerlink" title="ConfigManager"></a>ConfigManager</h2><p>ConfigManager主要是对DataProvider里面的方法进行封装，提供给外部功能接口实现配置的读取，解析，并且会存储解析好的全局配置数据，供外界使用。</p><h3 id="类内信息"><a href="#类内信息" class="headerlink" title="类内信息"></a>类内信息</h3><ul><li>m_configData：存储解析好的全局配置数据,提供给外界调用。根据其Value的ConfigData类型，可以得知支持的数据类型包括 int、float、string以及bool这四类。</li><li>m_DataProvider：模块的核心逻辑,用来读取配置文件。</li><li>m_configHelper：ConfigHelper的实例，用来解析配置文件。</li></ul><h2 id="DataProvider"><a href="#DataProvider" class="headerlink" title="DataProvider"></a>DataProvider</h2><p>Config模块的核心逻辑书写处，主要是通过获取的资源模块接口去读取配置文件，然后放入ConfigHelper里面进行解析。</p><h3 id="类内信息-1"><a href="#类内信息-1" class="headerlink" title="类内信息"></a>类内信息</h3><ul><li>BlockSize: 缓存块大小，用来缓存配置文件的二进制流。</li><li>s_CachedBytes: 用于存储缓存的二进制流。之所以专门在此定义一下是为了避免频繁的内存分配，提高效率的同时降低内存碎片的可能性。</li><li>m_Owner: 当前DataProvider的拥有者，也就是ConfigManager。DataProvider是GF的基础模块，这里是ConfigManager在使用，这样做自然也是为了方便使用者修改和拓展。</li><li>m_ResourceManager: 资源管理器接口，用来读取配置文件。</li><li>m_DataProviderHelper：DataProviderHelper的实例，用来解析配置文件。这里的话其实就是DefaultConfigHelper的实例。</li></ul><p>功能接口的也是支持对于文件（包含二进制文件）的读取，解析，存储。通过结构图和流程图已经能够直观了解到，这里不再赘述。</p><h3 id="二进制流的缓存与释放"><a href="#二进制流的缓存与释放" class="headerlink" title="二进制流的缓存与释放"></a>二进制流的缓存与释放</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 确保二进制流缓存分配足够大小的内存并缓存。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ensureSize&quot;&gt;</span>要确保二进制流缓存分配内存的大小。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnsureCachedBytesSize</span>(<span class="params"><span class="built_in">int</span> ensureSize</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ensureSize &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Ensure size is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s_CachedBytes == <span class="literal">null</span> || s_CachedBytes.Length &lt; ensureSize)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeCachedBytes();</span><br><span class="line">        <span class="built_in">int</span> size = (ensureSize - <span class="number">1</span> + BlockSize) / BlockSize * BlockSize;</span><br><span class="line">        s_CachedBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 释放缓存的二进制流。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FreeCachedBytes</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    s_CachedBytes = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DefaultConfigHelper"><a href="#DefaultConfigHelper" class="headerlink" title="DefaultConfigHelper"></a>DefaultConfigHelper</h2><p>这是GF默认的全局配置解析器，看到这里，可以了解到因为每个部分都是功能分明，相对独立的，整个模块都便于支持使用者根据自己的需求和功能去修改和拓展的。<br>这里简单举例说明一下DefaultConfigHelper的的解析规则。</p><p>比如，接下来我们存在如下的全局配置文件，其配置内容如下：</p><p>我们调用模块接口进行读取：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameEntry.Config.ReadData(configAssetName, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>来到DefaultConfigHelper的解析方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] ColumnSplitSeparator = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;\t&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> BytesAssetExtension = <span class="string">&quot;.bytes&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ColumnCount = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 解析全局配置。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;configManager&quot;&gt;</span>全局配置管理器。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;configString&quot;&gt;</span>要解析的全局配置字符串。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userData&quot;&gt;</span>用户自定义数据。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是否解析全局配置成功。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">ParseData</span>(<span class="params">IConfigManager configManager, <span class="built_in">string</span> configString, <span class="built_in">object</span> userData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> configLineString = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((configLineString = configString.ReadLine(<span class="keyword">ref</span> position)) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (configLineString[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span>[] splitedLine = configLineString.Split(ColumnSplitSeparator, StringSplitOptions.None);</span><br><span class="line">            <span class="keyword">if</span> (splitedLine.Length != ColumnCount)</span><br><span class="line">            &#123;</span><br><span class="line">                Log.Warning(<span class="string">&quot;Can not parse config line string &#x27;&#123;0&#125;&#x27; which column count is invalid.&quot;</span>, configLineString);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> configName = splitedLine[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">string</span> configValue = splitedLine[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (!configManager.AddConfig(configName, configValue))</span><br><span class="line">            &#123;</span><br><span class="line">                Log.Warning(<span class="string">&quot;Can not add config with config name &#x27;&#123;0&#125;&#x27; which may be invalid or duplicate.&quot;</span>, configName);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">    &#123;</span><br><span class="line">        Log.Warning(<span class="string">&quot;Can not parse config string with exception &#x27;&#123;0&#125;&#x27;.&quot;</span>, exception.ToString());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到通过以制表符为分割，将配置文件的每一行内容分割成四个字段（ColumnCount），获取到了第一个和第四个配置信息，并将其添加到ConfigManager里面。</p><p>使用的情况：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameEntry.Config.GetInt(<span class="string">&quot;Scene.Menu&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样，我们就实现了全局配置的定义，读取，解析，存储以及使用。</p>]]></content>
      
      
      <categories>
          
          <category> GameFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
            <tag> GameFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework解析：实体(Entity)</title>
      <link href="/2024/10/31/gf_entity/"/>
      <url>/2024/10/31/gf_entity/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你看过GF的UI模块，那么实体模块就会相当容易理解，因为实体模块的结构和UI模块有许多相似的地方。<br>先来看一下GF官方是如何定义的：</p><blockquote><p>我们将游戏场景中，动态创建的一切物体定义为实体。此模块提供管理实体和实体组的功能，如显示隐藏实体、挂接实体（如挂接武器、坐骑，或者抓起另一个实体）等。实体使用结束后可以不立刻销毁，从而等待下一次重新使用。</p></blockquote><h2 id="实体模块结构"><a href="#实体模块结构" class="headerlink" title="实体模块结构"></a>实体模块结构</h2><img src="/img/gf_entity.png" class="post-image" />从结构图上就可以看出，实体模块的确和UI模块的结构差不多，但也可以看见一些区别：<ul><li>EntityGroup对接的下层是IEntity，也就是Entity，而不是EntityInfo。而UI模块中，UIGroup里面接收管理的是UIFormInfo，而不是UIForm.</li><li>实体模块里面特有的功能是“附加”功能。实体可以附加其他实体，也可以被其他实体附加。</li><li>在EntityManager中，除了管理EntityGroup，还有m_EntityInfos来存储所有的实体。UI模块中，UIManager只会直接对接UIGroup，而不会直接管理UIFormInfo。</li></ul><p>接下来，我们从上往下一步一步进行拆解。</p><h2 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h2><p>EntityManager是外部访问框架实体模块的入口。提供给外部实体的显示、隐藏、附加、查找，获取等功能。这里从实体的生成和隐藏的流程和逻辑入手，说明EntityManager的工作原理和流程。</p><h3 id="ShowEntity流程"><a href="#ShowEntity流程" class="headerlink" title="ShowEntity流程"></a>ShowEntity流程</h3><img src="/img/gf_entity_process.png" class="post-image" /><h3 id="HideEntity流程"><a href="#HideEntity流程" class="headerlink" title="HideEntity流程"></a>HideEntity流程</h3><img src="/img/gf_entity_process_hideentity.png" class="post-image" /><h3 id="类内信息"><a href="#类内信息" class="headerlink" title="类内信息"></a>类内信息</h3><p>定义变量：</p><ul><li>m_EntityInfos：存储所有实体的列表。从结构上来讲，其实只需要一个m_EntityGroups就够了，但之所以整一个整体列表，目前还是为了方便查询和获取单个列表，经典的空间换时间。这也解释了为什么我们通过结构图上面看到的EntityGroup对接的是IEntity，而不是EntityInfo。</li><li>m_EntityGroups：存储所有实体组的列表。</li><li>m_EntitiesBeingLoaded: 正在加载的实体列表。这也是为了解决异步加载资源可能的冲突问题。</li><li>m_EntitiesToReleaseOnLoad: 待释放的实体列表。同样为了解决异步加载资源可能的冲突问题。注意这里的判断列表只是相当于一个用于判断的“标识”，与真正的实体回收逻辑无关。</li><li>m_RecycleQueue：回收实体队列。如果需要回收一个实体，会把此实体添加进当前的队列，待下一帧Update时，会把队列中的实体全部回收。</li><li>m_LoadAssetCallbacks：GF里封装了加载资源回调委托类，通过初始化实例，创建实体的时候传递给ResourceManager，资源加载完成后就会执行对应的方法。</li><li>m_ObjectPoolManager：对象池管理器。</li><li>m_ResoureceManager：资源管理器。</li><li>m_EntityHelper：实体辅助器。用于书写实体创建逻辑，开发者可以通过修改或者自写EntityHelper来实现自己的实体创建逻辑。这其实类似<span style="background-color:rgb(100,200,200,0.5)">工厂模式</span>，把创建和使用的逻辑进行了分离。</li><li>m_Serial: 实体生命周期内的唯一标识。每次创建实体的时候，都会进行自增，它是每个实体在其生命周期中内的唯一标识符。即使是同一个实体实例，在被隐藏放入对象池后重新取出使用的时候，其m_Serial也会发生变化。且它的自增在资源加载之前进行，并不依赖于资源加载完成逻辑。自然其存在对应的也是m_EntityInfos，m_EntitiesBeingLoaded，m_EntitiesToReleaseOnLoad里面key值。</li><li>m_IsShutDown: 当前模块是否关闭。</li></ul><p>提供功能：</p><ul><li>查询接口：提供GetEntityGroup，GetAllEntityGroups，HasEntity，GetEntity，GetEntities，GetAllLoadedEntities，IsLoadingEntity，GetAllLoadingEntityIds，IsValidEntity，GetParentEntity，GetChildEntityCount，GetChildEntities，GetEntityInfo来对实体和实体组进行查询和获取。</li><li>操作接口：AddEntityGroup，ShowEntity，HideEntity，HideAllLoadedEntities，AttachEntity，DetachEntity，DetachChildEntities，InternalShowEntity，InternalHideEntity来控制实体的显示，隐藏等操作。</li><li>EntityGroup管理与生命周期的传递：通过Dictionary&lt;string, EntityGroup&gt;的字典结构来存储所有的实体组。EntityManager的Update方法中会遍历整个字典，调用每一个EntityGroup的Update方法，而每个EntityGroup的Update里面又会以同样的方式调用每个实体的Update方法。如此就做到的生命周期的传递。</li><li>资源管理：在定义变量的时候，我们确实可以看到获取了对象池模块的管理器，但是并没有直接在EntityManager里面去定义对象池，而是在创建实体的时候，传递给实体组，在每个实体组里面去创建对应的对象池，用于缓存当前组的实例。这也是和UI模块的结构不同的地方。</li></ul><h2 id="EntityGroup"><a href="#EntityGroup" class="headerlink" title="EntityGroup"></a>EntityGroup</h2><p>通过上面，已经可以了解到EntityManager可以通过EntityGroup来管理实体，且可以通过轮询EntityGroup的Update方法，进而轮询Entity的Update方法，实现实体的生命周期的传递。以及每个EntityGroup里面有其对应的对象池，用于缓存当前组的实例。</p><p>EntityGroup作为EntityManager的内部类，其的主要作用就是管理其组内的实体，并提供相应的接口给EntityManager来对其组实体进行查询和操作。但是相对于UI模块里面，UIGroup里面包含的暂停，恢复，修改深度，刷新管理页面等功能，EntityGroup并没有这些功能，不需要这些规则，也自然不需要这样的功能，这才能保证实体模块在使用中的灵活性。<br>此外，说到存储实体的对象池分部到每一个EntityGroup里面，是因为每一种实体其实都是一个对象池。</p><p>那么分组按照什么来分呢？<br>这里的分组其实就是有一个种实体为其分一组。注意这里的说法，并不是说“一类实体分一组，一组内可以包含多种同类型的实体”，而是单纯的一类实体就是一个组。比如武器这个总的类型里面有3种敌人：敌人A，敌人B，敌人C，那么就分三个组————敌人A，敌人B，敌人C各自单独就是一组，因为这每一种敌人都可能被多次生成，所以一种就是一组，并不是说敌人一个组里面包含了这三种敌人。<br><img src="/img/gf_entity_config.png" class="post-image" /></p><h3 id="类内信息-1"><a href="#类内信息-1" class="headerlink" title="类内信息"></a>类内信息</h3><p>变量定义：</p><ul><li>m_Name：实体组的名称。</li><li>m_Entities：实体组内的存放当前组所有实体的链表。</li><li>m_InstancePool：实体组内的对象池。</li><li>m_EntityGroupHelper: 实体组辅助器。</li><li>m_CachedNodes：缓存的节点。起到标识以解决冲突的作用，这个缓存节点是用于解决执行当前实体Update和移除时候的冲突的。Update中通过此节点缓存，移除方法中通过此节点判断是否当前要移除的实体是否正在执行Update，如果是，那就给它跳过，避免出错。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// EntityManager.EntityGroup.cs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 实体组轮询。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;elapseSeconds&quot;&gt;</span>逻辑流逝时间，以秒为单位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;realElapseSeconds&quot;&gt;</span>真实流逝时间，以秒为单位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkedListNode&lt;IEntity&gt; current = m_Entities.First;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_CachedNode = current.Next;</span><br><span class="line">        current.Value.OnUpdate(elapseSeconds, realElapseSeconds);</span><br><span class="line">        current = m_CachedNode;</span><br><span class="line">        m_CachedNode = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 从实体组移除实体。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;entity&quot;&gt;</span>要移除的实体。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveEntity</span>(<span class="params">IEntity entity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_CachedNode != <span class="literal">null</span> &amp;&amp; m_CachedNode.Value == entity)</span><br><span class="line">    &#123;</span><br><span class="line">        m_CachedNode = m_CachedNode.Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_Entities.Remove(entity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Entity group &#x27;&#123;0&#125;&#x27; not exists specified entity &#x27;[&#123;1&#125;]&#123;2&#125;&#x27;.&quot;</span>, m_Name, entity.Id.ToString(), entity.EntityAssetName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供功能：</p><ul><li>查询接口：HasEntity，GetEntity，GetEntities，GetAllEntities可以查询和获取对应的实体。</li><li>操作接口：AddEntity，RemoveEntity可以对实体组进行操作。</li><li>对象池相关操作接口：RegisterEntityInstanceObject，SpawnEntityInstanceObject，UnspawnEntity，SetEntityInstanceLocked，SetEntityInstancePriority能够设置控制当前组内对象池。</li></ul><h2 id="EntityInfo"><a href="#EntityInfo" class="headerlink" title="EntityInfo"></a>EntityInfo</h2><p>和EntityGroup一样，EntityInfo都是EntityManager的内部类，m_EntityInfos里面装的并不是IEntiy，而是EntityInfo。EntityInfo对Entity的相关信息进行了一层封装，里面除了包含对应的实体实例之外，还包含了当前实例的状态，EntityManager在设置和获取实体的状态时候，都是通过设置m_EntityInfos里面对应EnttiyInfo进行的。<br>里面主要就四个东西对应四个功能：</p><ul><li>m_Entity: 实体实例。</li><li>m_Status: 当前实体的状态。对应其生命周期。</li><li>m_ParentEntity: 父实体。用于控制当前实体附加的父实体。</li><li>m_ChildEntities: 子实体列表。用于控制附加在此实体上的子实体。</li></ul><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>GF层里面提供的是IEntity接口，UGF层里面的Entity类实现了此接口。通过上面的打开流程可以得知，在通过Entity脚本是通过EntityHelper创建并添加到其实体上的，以让此实体接收EntityManager和其对应的EntityGroup的管理。</p><p>Entity在这里两个作用：</p><ul><li>让当前实体接收EntityManager和EntityGroup的管理。</li><li>传递生命周期给逻辑层EntityLogic。</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>OnInit &amp; OnRecycle<ul><li>OnInit:在EntityManager执行ShowEntity的时候被调用。初始化Id和资源名称之后，获取或者创建EntityLogic到当前的实体上，并执行EnityLogic的OnInit方法。</li><li>OnRecycle:在EntityManager执行HideEntity的时候被调用。执行EntityLogic的OnRecycle方法，并关闭其EntityLogic，让当前Id归零。</li></ul></li><li>OnShow &amp; OnHide<ul><li>OnShow:OnInit执行后调用。执行EntityLogic的OnShow方法</li><li>OnHide:OnRecycle执行之前调用。执行EntityLogic的OnHide方法。</li></ul></li><li>OnAttached &amp; OnDetached | OnAttachTo &amp; OnDetachFrom<ul><li>OnAttached:当实体附加其他实体时被调用。</li><li>OnDetached:当实体被解除其附加实体的时候被调用。</li><li>OnAttachTo:当实体被附加在其他实体上时被调用。</li><li>OnDetachFrom:当实体被从其附加的实体上解除的时候调用。</li></ul></li><li>OnUpdate：通过EntityGroup传递。</li></ul><h2 id="EntityLogic"><a href="#EntityLogic" class="headerlink" title="EntityLogic"></a>EntityLogic</h2><p>EntityLogic是实体书写业务逻辑的地方，它接受了Entity传递过来的生命周期，对于任何的基层逻辑我们都可以在EntityLogic里面书写，比如在默认逻辑里面如果一个实体被隐藏了，除了其GO被对象池回收外，此GO会因为EntityLogic的OnHide方法被设置不可见，我们只需要根据当前需求去书写当前实体的业务逻辑即可。<br>不过，一般的话，并不会直接在基层的EntityLogic里面写太多的逻辑，而是通过继承EntityLogic，然后重写并拓展其中的方法来实现自己的业务逻辑。另外，如果是自己重写了EntityLogic，那么就需要提前挂载对应的脚本到实体预制体上面，否则Entity只会添加一个默认的EntityLogic。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://gameframework.cn/document/entity/">GF官方文档</a></li><li><a href="https://blog.csdn.net/qq_37619255/article/details/129624414">好啊的使用说明</a></li><li><a href="https://www.drflower.top/posts/16213a73/">花卷整理的GF中的UI模块</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GameFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实体 </tag>
            
            <tag> GameFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework解析：事件(Event)</title>
      <link href="/2024/10/27/gf_event/"/>
      <url>/2024/10/27/gf_event/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>事件模块是游戏中很重要的一个模块，而GameFramework的事件模块在网上能找到很多文章，但基本都是讲解其应用方面的，并没有对其源码进行分析。<br>这里阐述此模块通过如下三个方面：基本的类内信息说明，GF里面存储管理事件的形式，事件抛出和取消订阅的冲突问题。<br>这里就不用应用举例了，有需要可以查看下面参考文档。</p><h2 id="Event模块结构"><a href="#Event模块结构" class="headerlink" title="Event模块结构"></a>Event模块结构</h2><img src="/img/gf_event.png" class="post-image" /><p>从上面的结构图也可以看出，EventManager作为事件模块的管理器，其作用主要是对于EventPool的功能进行封装，并提供对应的接口给外部使用。因此本模块的核心逻辑主要在EventPool中。</p><h2 id="EventPool"><a href="#EventPool" class="headerlink" title="EventPool"></a>EventPool</h2><p>作为事件模块的核心， EventPool处理着事件的发布、订阅、移除等功能的同时也会严格检查事件订阅的匹配情况，不允许出现重复订阅，也不允许出现重复取消订阅或取消订阅尚未订阅的事件处理函数，如果出现这些情况，将会抛出异常。<br>观察者模式可以从“发布者”和“订阅者”两个角度来看，EventPool里面对应的两个方面便是 “事件” 和 “事件处理函数” 。事件处理函数是订阅者注册给发布者的，一个事件可以包含多个事件处理函数。抛出一个事件，会执行其所有订阅者的事件处理函数。</p><h3 id="类内信息"><a href="#类内信息" class="headerlink" title="类内信息"></a>类内信息</h3><ul><li>字段功能说明：<ul><li>m_EventHandlers：GF多值字典。key为事件ID，value为事件处理函数的列表，毕竟一个事件可以有多个订阅者，GF是通过多值字典来存储的。</li><li>m_Events：事件队列。这里的事件(Event)是EventPool中的一个内部类，主要用于记录当前正在抛出的事件。因为其在Update里面执行，可以确保安全性，保证在主线程中回调处理函数，但事件会在抛出后的下一帧分发。</li><li>m_CachedNotes：事件节点缓存字典。缓存正在抛出的事件节点，用于解决正在抛出事件节点和取消订阅事件节点的冲突问题。通过检测m_CachedNotes里面的数据可以判断当前要取消订阅的事件是否正在被抛出。</li><li>m_TempNodes：临时事件节点列表。缓存m_CachedNotes里面的节点。在取消订阅的时候，如果当前取消的事件正在被抛出的话，就缓存下一个节点到m_TempNodes，然后给m_cachedNotes里面覆盖赋值，跳过这一个节点的事件派发。</li><li>m_EventPoolMode：事件池模式。这里的模式主要用于控制事件池的事件处理函数的执行模型，参考EventPoolMode枚举分为四种：<ul><li>Default，默认事件池模式，即必须存在有且只有一个事件处理函数。</li><li>AllowNoHandler，允许不存在事件处理函数。</li><li>AllowMultiHandler，允许存在多个事件处理函数。</li><li>AllowDuplicateHandler，允许存在重复的事件处理函数。<br>一般的话使用的是EventPoolMode.AllowNoHandler | EventPoolMode.AllowMultiHandler 这两个模式</li></ul></li><li>m_DefaultHandler：默认额外事件处理函数。通过给这个委托赋值，可以设置一个额外的的事件处理函数，当抛出事件后，如果有此委托有内容，就会调用，方便进行拓展。</li></ul></li><li>方法说明：<ul><li>Update：生命周期里轮询方法。这里会检测事件列表里面的事件进行派发，并调用对应的事件处理函数。</li><li>Shutdown：关闭并清理事件池。</li><li>Clear：清空当前待处理的事件列表。</li><li>Count：获取对应事件的事件处理函数的数量。</li><li>Check：检查对应事件是否存在事件处理函数。</li><li>Subscribe：订阅事件。</li><li>Unsubscribe：取消订阅事件。</li><li>SetDefaultHandler：设置默认额外事件处理函数。</li><li>Fire和FireNow: 都是抛出事件，Fire会走上面的流程。而FireNow则是立刻执行，这个操作不是线程安全的，但事件会立刻分发。</li><li>HandleEvent：处理事件和事件函数的核心方法。</li></ul></li></ul><p>EventPool源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GameFramework</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 事件池。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>事件类型。<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">EventPool</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">BaseEventArgs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> GameFrameworkMultiDictionary&lt;<span class="built_in">int</span>, EventHandler&lt;T&gt;&gt; m_EventHandlers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Queue&lt;Event&gt; m_Events;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; m_CachedNodes;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; m_TempNodes;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> EventPoolMode m_EventPoolMode;</span><br><span class="line">        <span class="keyword">private</span> EventHandler&lt;T&gt; m_DefaultHandler;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 初始化事件池的新实例。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;mode&quot;&gt;</span>事件池模式。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EventPool</span>(<span class="params">EventPoolMode mode</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_EventHandlers = <span class="keyword">new</span> GameFrameworkMultiDictionary&lt;<span class="built_in">int</span>, EventHandler&lt;T&gt;&gt;();</span><br><span class="line">            m_Events = <span class="keyword">new</span> Queue&lt;Event&gt;();</span><br><span class="line">            m_CachedNodes = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt;();</span><br><span class="line">            m_TempNodes = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt;();</span><br><span class="line">            m_EventPoolMode = mode;</span><br><span class="line">            m_DefaultHandler = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取事件处理函数的数量。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> EventHandlerCount</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_EventHandlers.Count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取事件数量。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> EventCount</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_Events.Count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 事件池轮询。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;elapseSeconds&quot;&gt;</span>逻辑流逝时间，以秒为单位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;realElapseSeconds&quot;&gt;</span>真实流逝时间，以秒为单位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"><span class="built_in">float</span> elapseSeconds, <span class="built_in">float</span> realElapseSeconds</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (m_Events.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Event eventNode = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">lock</span> (m_Events)</span><br><span class="line">                &#123;</span><br><span class="line">                    eventNode = m_Events.Dequeue();</span><br><span class="line">                    HandleEvent(eventNode.Sender, eventNode.EventArgs);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ReferencePool.Release(eventNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 关闭并清理事件池。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shutdown</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Clear();</span><br><span class="line">            m_EventHandlers.Clear();</span><br><span class="line">            m_CachedNodes.Clear();</span><br><span class="line">            m_TempNodes.Clear();</span><br><span class="line">            m_DefaultHandler = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 清理事件。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (m_Events)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Events.Clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取事件处理函数的数量。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span>事件类型编号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>事件处理函数的数量。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Count</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt;);</span><br><span class="line">            <span class="keyword">if</span> (m_EventHandlers.TryGetValue(id, <span class="keyword">out</span> range))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> range.Count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 检查是否存在事件处理函数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span>事件类型编号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handler&quot;&gt;</span>要检查的事件处理函数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是否存在事件处理函数。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Check</span>(<span class="params"><span class="built_in">int</span> id, EventHandler&lt;T&gt; handler</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event handler is invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m_EventHandlers.Contains(id, handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 订阅事件处理函数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span>事件类型编号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handler&quot;&gt;</span>要订阅的事件处理函数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params"><span class="built_in">int</span> id, EventHandler&lt;T&gt; handler</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event handler is invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!m_EventHandlers.Contains(id))</span><br><span class="line">            &#123;</span><br><span class="line">                m_EventHandlers.Add(id, handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((m_EventPoolMode &amp; EventPoolMode.AllowMultiHandler) != EventPoolMode.AllowMultiHandler)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not allow multi handler.&quot;</span>, id.ToString()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((m_EventPoolMode &amp; EventPoolMode.AllowDuplicateHandler) != EventPoolMode.AllowDuplicateHandler &amp;&amp; Check(id, handler))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not allow duplicate handler.&quot;</span>, id.ToString()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_EventHandlers.Add(id, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 取消订阅事件处理函数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span>事件类型编号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handler&quot;&gt;</span>要取消订阅的事件处理函数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params"><span class="built_in">int</span> id, EventHandler&lt;T&gt; handler</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event handler is invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_CachedNodes.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; cachedNode <span class="keyword">in</span> m_CachedNodes)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cachedNode.Value != <span class="literal">null</span> &amp;&amp; cachedNode.Value.Value == handler)</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_TempNodes.Add(cachedNode.Key, cachedNode.Value.Next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_TempNodes.Count &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; cachedNode <span class="keyword">in</span> m_TempNodes)</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_CachedNodes[cachedNode.Key] = cachedNode.Value;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    m_TempNodes.Clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!m_EventHandlers.Remove(id, handler))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not exists specified handler.&quot;</span>, id.ToString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 设置默认事件处理函数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handler&quot;&gt;</span>要设置的默认事件处理函数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDefaultHandler</span>(<span class="params">EventHandler&lt;T&gt; handler</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_DefaultHandler = handler;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 抛出事件，这个操作是线程安全的，即使不在主线程中抛出，也可保证在主线程中回调事件处理函数，但事件会在抛出后的下一帧分发。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件源。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>事件参数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fire</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event is invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Event eventNode = Event.Create(sender, e);</span><br><span class="line">            <span class="keyword">lock</span> (m_Events)</span><br><span class="line">            &#123;</span><br><span class="line">                m_Events.Enqueue(eventNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 抛出事件立即模式，这个操作不是线程安全的，事件会立刻分发。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件源。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>事件参数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FireNow</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event is invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HandleEvent(sender, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 处理事件结点。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件源。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>事件参数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> noHandlerException = <span class="literal">false</span>;</span><br><span class="line">            GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt;);</span><br><span class="line">            <span class="keyword">if</span> (m_EventHandlers.TryGetValue(e.Id, <span class="keyword">out</span> range))</span><br><span class="line">            &#123;</span><br><span class="line">                LinkedListNode&lt;EventHandler&lt;T&gt;&gt; current = range.First;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current != range.Terminal)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_CachedNodes[e] = current.Next != range.Terminal ? current.Next : <span class="literal">null</span>;</span><br><span class="line">                    current.Value(sender, e);</span><br><span class="line">                    current = m_CachedNodes[e];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                m_CachedNodes.Remove(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_DefaultHandler != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_DefaultHandler(sender, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((m_EventPoolMode &amp; EventPoolMode.AllowNoHandler) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                noHandlerException = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReferencePool.Release(e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (noHandlerException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not allow no handler.&quot;</span>, e.Id.ToString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多值字典和链表范围"><a href="#多值字典和链表范围" class="headerlink" title="多值字典和链表范围"></a>多值字典和链表范围</h3><p>GameFramework的多值字典(GameFrameworkMultiDictionary)和链表范围(GameFrameworkLinkedListRange)是GameFramework的基础模块。这里的目的是为了满足同一事件多个事件处理函数的需求。是GF里面存储管理事件的形式。</p><p>先说链表范围，链表范围这个说法顾名思义，表示的就是“链表中的某个范围”。通过确定起始节点和终止节点，就可以确定一个链表范围。这里的作用是用于确定单个事件所包含哪些事件处理函数。<br>多值字典里面包含两个定义m_LinkedList 和 m_Dictionary：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> GameFrameworkLinkedList&lt;TValue&gt; m_LinkedList;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt; m_Dictionary;</span><br></pre></td></tr></table></figure><p>通过m_LinkedList链表来存储所有的事件处理函数，m_Dictionary则是根据事件ID来存储对应事件处理函数的链表范围。这样做的好处便是，只需要通过一条链表就可以确定好一个事件有哪些事件处理函数，而不需要每一个事件都去单独创建一个链表去填充。</p><p>源码：<br>GameFrameworkMultiDictionary：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GameFramework</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 游戏框架多值字典类。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TKey&quot;&gt;</span>指定多值字典的主键类型。<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;TValue&quot;&gt;</span>指定多值字典的值类型。<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">GameFrameworkMultiDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt; : <span class="title">IEnumerable</span>&lt;<span class="title">KeyValuePair</span>&lt;<span class="title">TKey</span>, <span class="title">GameFrameworkLinkedListRange</span>&lt;<span class="title">TValue</span>&gt;&gt;&gt;, <span class="title">IEnumerable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> GameFrameworkLinkedList&lt;TValue&gt; m_LinkedList;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt; m_Dictionary;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 初始化游戏框架多值字典类的新实例。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GameFrameworkMultiDictionary</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_LinkedList = <span class="keyword">new</span> GameFrameworkLinkedList&lt;TValue&gt;();</span><br><span class="line">            m_Dictionary = <span class="keyword">new</span> Dictionary&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取多值字典中实际包含的主键数量。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_Dictionary.Count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取多值字典中指定主键的范围。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>指定的主键。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>指定主键的范围。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> GameFrameworkLinkedListRange&lt;TValue&gt; <span class="keyword">this</span>[TKey key]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                GameFrameworkLinkedListRange&lt;TValue&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;TValue&gt;);</span><br><span class="line">                m_Dictionary.TryGetValue(key, <span class="keyword">out</span> range);</span><br><span class="line">                <span class="keyword">return</span> range;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 清理多值字典。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_Dictionary.Clear();</span><br><span class="line">            m_LinkedList.Clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 检查多值字典中是否包含指定主键。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>要检查的主键。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>多值字典中是否包含指定主键。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params">TKey key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Dictionary.ContainsKey(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 检查多值字典中是否包含指定值。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>要检查的主键。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>要检查的值。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>多值字典中是否包含指定值。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameFrameworkLinkedListRange&lt;TValue&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;TValue&gt;);</span><br><span class="line">            <span class="keyword">if</span> (m_Dictionary.TryGetValue(key, <span class="keyword">out</span> range))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> range.Contains(<span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 尝试获取多值字典中指定主键的范围。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>指定的主键。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;range&quot;&gt;</span>指定主键的范围。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是否获取成功。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">TryGetValue</span>(<span class="params">TKey key, <span class="keyword">out</span> GameFrameworkLinkedListRange&lt;TValue&gt; range</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_Dictionary.TryGetValue(key, <span class="keyword">out</span> range);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 向指定的主键增加指定的值。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>指定的主键。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>指定的值。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameFrameworkLinkedListRange&lt;TValue&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;TValue&gt;);</span><br><span class="line">            <span class="keyword">if</span> (m_Dictionary.TryGetValue(key, <span class="keyword">out</span> range))</span><br><span class="line">            &#123;</span><br><span class="line">                m_LinkedList.AddBefore(range.Terminal, <span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LinkedListNode&lt;TValue&gt; first = m_LinkedList.AddLast(<span class="keyword">value</span>);</span><br><span class="line">                LinkedListNode&lt;TValue&gt; terminal = m_LinkedList.AddLast(<span class="literal">default</span>(TValue));</span><br><span class="line">                m_Dictionary.Add(key, <span class="keyword">new</span> GameFrameworkLinkedListRange&lt;TValue&gt;(first, terminal));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 从指定的主键中移除指定的值。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>指定的主键。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>指定的值。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是否移除成功。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameFrameworkLinkedListRange&lt;TValue&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;TValue&gt;);</span><br><span class="line">            <span class="keyword">if</span> (m_Dictionary.TryGetValue(key, <span class="keyword">out</span> range))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (LinkedListNode&lt;TValue&gt; current = range.First; current != <span class="literal">null</span> &amp;&amp; current != range.Terminal; current = current.Next)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current.Value.Equals(<span class="keyword">value</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (current == range.First)</span><br><span class="line">                        &#123;</span><br><span class="line">                            LinkedListNode&lt;TValue&gt; next = current.Next;</span><br><span class="line">                            <span class="keyword">if</span> (next == range.Terminal)</span><br><span class="line">                            &#123;</span><br><span class="line">                                m_LinkedList.Remove(next);</span><br><span class="line">                                m_Dictionary.Remove(key);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                m_Dictionary[key] = <span class="keyword">new</span> GameFrameworkLinkedListRange&lt;TValue&gt;(next, range.Terminal);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        m_LinkedList.Remove(current);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 从指定的主键中移除所有的值。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>指定的主键。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是否移除成功。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">RemoveAll</span>(<span class="params">TKey key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameFrameworkLinkedListRange&lt;TValue&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;TValue&gt;);</span><br><span class="line">            <span class="keyword">if</span> (m_Dictionary.TryGetValue(key, <span class="keyword">out</span> range))</span><br><span class="line">            &#123;</span><br><span class="line">                m_Dictionary.Remove(key);</span><br><span class="line"></span><br><span class="line">                LinkedListNode&lt;TValue&gt; current = range.First;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    LinkedListNode&lt;TValue&gt; next = current != range.Terminal ? current.Next : <span class="literal">null</span>;</span><br><span class="line">                    m_LinkedList.Remove(current);</span><br><span class="line">                    current = next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 返回循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>循环访问集合的枚举数。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Enumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Enumerator(m_Dictionary);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 返回循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>循环访问集合的枚举数。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        IEnumerator&lt;KeyValuePair&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt;&gt;.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 返回循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>循环访问集合的枚举数。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> Enumerator : IEnumerator&lt;KeyValuePair&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt;&gt;, IEnumerator</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> Dictionary&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt;.Enumerator m_Enumerator;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">internal</span> <span class="title">Enumerator</span>(<span class="params">Dictionary&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt; dictionary</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictionary == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Dictionary is invalid.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                m_Enumerator = dictionary.GetEnumerator();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 获取当前结点。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> KeyValuePair&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt; Current</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_Enumerator.Current;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 获取当前的枚举数。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="built_in">object</span> IEnumerator.Current</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_Enumerator.Current;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 清理枚举数。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_Enumerator.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 获取下一个结点。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回下一个结点。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_Enumerator.MoveNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 重置枚举数。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">void</span> IEnumerator.Reset()</span><br><span class="line">            &#123;</span><br><span class="line">                ((IEnumerator&lt;KeyValuePair&lt;TKey, GameFrameworkLinkedListRange&lt;TValue&gt;&gt;&gt;)m_Enumerator).Reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GameFrameworkLinkedListRange：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GameFramework</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 游戏框架链表范围。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>指定链表范围的元素类型。<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    [<span class="meta">StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> GameFrameworkLinkedListRange&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> LinkedListNode&lt;T&gt; m_First;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> LinkedListNode&lt;T&gt; m_Terminal;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 初始化游戏框架链表范围的新实例。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;first&quot;&gt;</span>链表范围的开始结点。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;terminal&quot;&gt;</span>链表范围的终结标记结点。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GameFrameworkLinkedListRange</span>(<span class="params">LinkedListNode&lt;T&gt; first, LinkedListNode&lt;T&gt; terminal</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span> || terminal == <span class="literal">null</span> || first == terminal)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Range is invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_First = first;</span><br><span class="line">            m_Terminal = terminal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取链表范围是否有效。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> IsValid</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_First != <span class="literal">null</span> &amp;&amp; m_Terminal != <span class="literal">null</span> &amp;&amp; m_First != m_Terminal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取链表范围的开始结点。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> LinkedListNode&lt;T&gt; First</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_First;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取链表范围的终结标记结点。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> LinkedListNode&lt;T&gt; Terminal</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> m_Terminal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取链表范围的结点数量。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!IsValid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (LinkedListNode&lt;T&gt; current = m_First; current != <span class="literal">null</span> &amp;&amp; current != m_Terminal; current = current.Next)</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 检查是否包含指定值。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>要检查的值。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是否包含指定值。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (LinkedListNode&lt;T&gt; current = m_First; current != <span class="literal">null</span> &amp;&amp; current != m_Terminal; current = current.Next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.Value.Equals(<span class="keyword">value</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 返回循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>循环访问集合的枚举数。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Enumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Enumerator(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 返回循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>循环访问集合的枚举数。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 返回循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>循环访问集合的枚举数。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> Enumerator : IEnumerator&lt;T&gt;, IEnumerator</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">readonly</span> GameFrameworkLinkedListRange&lt;T&gt; m_GameFrameworkLinkedListRange;</span><br><span class="line">            <span class="keyword">private</span> LinkedListNode&lt;T&gt; m_Current;</span><br><span class="line">            <span class="keyword">private</span> T m_CurrentValue;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">internal</span> <span class="title">Enumerator</span>(<span class="params">GameFrameworkLinkedListRange&lt;T&gt; range</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!range.IsValid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Range is invalid.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                m_GameFrameworkLinkedListRange = range;</span><br><span class="line">                m_Current = m_GameFrameworkLinkedListRange.m_First;</span><br><span class="line">                m_CurrentValue = <span class="literal">default</span>(T);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 获取当前结点。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> T Current</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_CurrentValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 获取当前的枚举数。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="built_in">object</span> IEnumerator.Current</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> m_CurrentValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 清理枚举数。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 获取下一个结点。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回下一个结点。<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_Current == <span class="literal">null</span> || m_Current == m_GameFrameworkLinkedListRange.m_Terminal)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                m_CurrentValue = m_Current.Value;</span><br><span class="line">                m_Current = m_Current.Next;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 重置枚举数。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">void</span> IEnumerator.Reset()</span><br><span class="line">            &#123;</span><br><span class="line">                m_Current = m_GameFrameworkLinkedListRange.m_First;</span><br><span class="line">                m_CurrentValue = <span class="literal">default</span>(T);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解决抛出和取消订阅同一事件的冲突"><a href="#解决抛出和取消订阅同一事件的冲突" class="headerlink" title="解决抛出和取消订阅同一事件的冲突"></a>解决抛出和取消订阅同一事件的冲突</h3><p>上面也说到，在事件抛出的时候，如果收到了此事件的取消订阅，这时候就会出现冲突，这里的处理方式是通过m_CachedNodes和m_TempNodes两个事件节点缓存字典来解决。如果但看HandleEvent方法，就会发现这里的缓存其实是没有绝对的功能执行必要的，而之所以添加的目的也就是添加判断冲突存在的“标识”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 处理事件结点。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件源。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>事件参数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> noHandlerException = <span class="literal">false</span>;</span><br><span class="line">    GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt; range = <span class="literal">default</span>(GameFrameworkLinkedListRange&lt;EventHandler&lt;T&gt;&gt;);</span><br><span class="line">    <span class="keyword">if</span> (m_EventHandlers.TryGetValue(e.Id, <span class="keyword">out</span> range))</span><br><span class="line">    &#123;</span><br><span class="line">        LinkedListNode&lt;EventHandler&lt;T&gt;&gt; current = range.First;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current != range.Terminal)</span><br><span class="line">        &#123;</span><br><span class="line">            m_CachedNodes[e] = current.Next != range.Terminal ? current.Next : <span class="literal">null</span>;</span><br><span class="line">            current.Value(sender, e);</span><br><span class="line">            current = m_CachedNodes[e];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_CachedNodes.Remove(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_DefaultHandler != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_DefaultHandler(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((m_EventPoolMode &amp; EventPoolMode.AllowNoHandler) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        noHandlerException = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferencePool.Release(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noHandlerException)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not allow no handler.&quot;</span>, e.Id.ToString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 取消订阅事件处理函数。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span>事件类型编号。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handler&quot;&gt;</span>要取消订阅的事件处理函数。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params"><span class="built_in">int</span> id, EventHandler&lt;T&gt; handler</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(<span class="string">&quot;Event handler is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_CachedNodes.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; cachedNode <span class="keyword">in</span> m_CachedNodes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedNode.Value != <span class="literal">null</span> &amp;&amp; cachedNode.Value.Value == handler)</span><br><span class="line">            &#123;</span><br><span class="line">                m_TempNodes.Add(cachedNode.Key, cachedNode.Value.Next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_TempNodes.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">object</span>, LinkedListNode&lt;EventHandler&lt;T&gt;&gt;&gt; cachedNode <span class="keyword">in</span> m_TempNodes)</span><br><span class="line">            &#123;</span><br><span class="line">                m_CachedNodes[cachedNode.Key] = cachedNode.Value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_TempNodes.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_EventHandlers.Remove(id, handler))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GameFrameworkException(Utility.Text.Format(<span class="string">&quot;Event &#x27;&#123;0&#125;&#x27; not exists specified handler.&quot;</span>, id.ToString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://gameframework.cn/document/event/">GF官方文档</a></li><li><a href="https://www.lfzxb.top/gameframework-diyevent/">烟雨的自定义事件案例</a></li><li><a href="https://blog.csdn.net/J_avaSmallWhite/article/details/122591528">来自白小飞</a></li><li><a href="https://busyogg.github.io/article/2474251272a9/">Busyo的自定义事件系统</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GameFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GameFramework </tag>
            
            <tag> 事件系统 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#：委托与事件</title>
      <link href="/2024/10/27/CSharp_DelegateAndEvent%20copy/"/>
      <url>/2024/10/27/CSharp_DelegateAndEvent%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为接下来想要整理一下游戏里面的事件模块，而当前项目的业务开发都是通过 Lua 进行的，有一阵子没有写 C#了，回想 C#的委托和事件，有些细节一时模糊了起来，所以打算干脆把相关的知识点整理一下，就当做复习了。</p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h3><p>无论是委托还是事件官网都没有一个简单直白的定义，只能说理解万岁。<br></p><blockquote><p>委托：用于封装方法的一种引用类型，类似于 C++的指针，但其类型安全可靠。通过封装多个方法到一个变量中，调用此变量就可以调用所有绑定的方法。你也可以将它理解性地看做“方法的容器”。</p></blockquote><h3 id="委托的写法"><a href="#委托的写法" class="headerlink" title="委托的写法"></a>委托的写法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> ---- 普通写法------</span></span><br><span class="line"><span class="comment">// 1.定义委托类型，这一步定义的是委托的类型，并不是委托的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>()</span>;</span><br><span class="line"><span class="comment">//2.定义委托变量</span></span><br><span class="line"><span class="keyword">public</span> MyEventHandler MyEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛式委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>&gt;(<span class="params">T1 arg1, T2 arg2</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyEventHandler</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; MyEvent</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带返回值的委托，若多个返回值发生，保留最后注册的那个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">MyEventHandler</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T1 arg</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> MyEventHandler&lt;T1, TResult&gt; MyEvent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 匿名方法写法，省去了定义类型的步骤------</span></span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="keyword">public</span> Action MyEventHandler;</span><br><span class="line"><span class="keyword">public</span> Action&lt;<span class="keyword">in</span> T&gt; MyEventHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有返回值</span></span><br><span class="line"><span class="keyword">public</span> Func&lt;<span class="built_in">int</span>&gt; MyEventHandler;</span><br><span class="line"><span class="keyword">public</span> Func&lt;<span class="keyword">in</span> T, <span class="keyword">out</span> TResult&gt; MyEventHandler;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/img/delegateRelation.png" class="post-image" /><h3 id="委托的作用"><a href="#委托的作用" class="headerlink" title="委托的作用"></a>委托的作用</h3><p>熟练使用委托可以提高代码的拓展性，优化代码结构。<br></p><p>这种拓展性的应用场景主要体现在于两个方面：</p><ol><li>代码结构不变的情况，执行处需要在不同的环境下给委托赋值不同的方法，就可以执行不同的功能。</li><li>一个功能的触发，涉及到多个方法的执行。</li></ol><p>先说第一种应用，这里以 GameFramework 框架中的写法举例，在 GameFramework 框架中（后面成为 GF）可以分为 GF 层和 UGF 层，GF 层的逻辑是功能的核心逻辑，而 UGF 层则是 GF 在 Unity 的应用。在 GF 的 UI 模块，一个页面的打开&#x2F;关闭的完成正如其他 UI 框架很可能执行的逻辑一样，通过事件系统派发出了一个 UI 页面打开&#x2F;关闭的事件。而为了保证 GF 层的结构和功能不变动，提供框架使用者可以根据情况自由拓展或者改变这样的操作。GF 层打开&#x2F;关闭页面的 Internal 逻辑执行完成后，并没有直接调用事件模块的接口，而是执行了一个委托。 在 UGF 层，使用者就可以通过绑定自己的方法到这个委托上，来实现自己的页面打开&#x2F;关闭后的处理逻辑，而不会完全不需要接触和改动 GF 层的代码。让我们直接看一下代码写法，<br></p><p>GF层的UIManager:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//GF层，UIManager.cs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义委托，这里你可能觉得诡异，委托的定义居然是使用Private关键字，这个我们在后面事件的时候进行说明</span></span><br><span class="line"><span class="keyword">private</span> EventHandler&lt;OpenUIFormSuccessEventArgs&gt; m_OpenUIFormSuccessEventHandler;</span><br><span class="line"><span class="keyword">private</span> EventHandler&lt;OpenUIFormFailureEventArgs&gt; m_OpenUIFormFailureEventHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供绑定接口，这里通过事件进行绑定，之所以不直接用委托，这个后面说明。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开界面成功事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;OpenUIFormSuccessEventArgs&gt; OpenUIFormSuccess</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormSuccessEventHandler += <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">remove</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormSuccessEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开界面失败事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;OpenUIFormFailureEventArgs&gt; OpenUIFormFailure</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormFailureEventHandler += <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">remove</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormFailureEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//页面打开或关闭执行对应的委托</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开页面</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalOpenUIForm</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//.................省略页面打开成功逻辑......................</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//页面打开逻辑后执行完成回调</span></span><br><span class="line">  <span class="keyword">if</span> (m_OpenUIFormSuccessEventHandler != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      OpenUIFormSuccessEventArgs openUIFormSuccessEventArgs = OpenUIFormSuccessEventArgs.Create(uiForm, duration, userData);</span><br><span class="line">      m_OpenUIFormSuccessEventHandler(<span class="keyword">this</span>, openUIFormSuccessEventArgs);</span><br><span class="line">      ReferencePool.Release(openUIFormSuccessEventArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 关闭界面。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseUIForm</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//.................省略页面关闭成功逻辑......................</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//页面关闭逻辑后执行完成回调</span></span><br><span class="line">  <span class="keyword">if</span> (m_CloseUIFormCompleteEventHandler != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      CloseUIFormCompleteEventArgs closeUIFormCompleteEventArgs = CloseUIFormCompleteEventArgs.Create(uiForm.SerialId, uiForm.UIFormAssetName, uiGroup, userData);</span><br><span class="line">      m_CloseUIFormCompleteEventHandler(<span class="keyword">this</span>, closeUIFormCompleteEventArgs);</span><br><span class="line">      ReferencePool.Release(closeUIFormCompleteEventArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UGF层,UIComponent中的使用形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --------绑定方法--------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 游戏框架组件初始化。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">base</span>.Awake();</span><br><span class="line">  <span class="comment">//获取GF层的UIManager</span></span><br><span class="line">  m_UIManager = GameFrameworkEntry.GetModule&lt;IUIManager&gt;();</span><br><span class="line">  <span class="keyword">if</span> (m_UIManager == <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      Log.Fatal(<span class="string">&quot;UI manager is invalid.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断绑定需求，如果需要，则绑定事件，这一步使用者就可以根据自己的需求进行自定义功能添加了</span></span><br><span class="line">  <span class="keyword">if</span> (m_EnableOpenUIFormSuccessEvent)</span><br><span class="line">  &#123;</span><br><span class="line">      m_UIManager.OpenUIFormSuccess += OnOpenUIFormSuccess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m_UIManager.OpenUIFormFailure += OnOpenUIFormFailure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------添加的方法--------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件模块，派发UI打开/关闭的事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOpenUIFormSuccess</span>(<span class="params"><span class="built_in">object</span> sender, GameFramework.UI.OpenUIFormSuccessEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_EventComponent.Fire(<span class="keyword">this</span>, OpenUIFormSuccessEventArgs.Create(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOpenUIFormFailure</span>(<span class="params"><span class="built_in">object</span> sender, GameFramework.UI.OpenUIFormFailureEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Log.Warning(<span class="string">&quot;Open UI form failure, asset name &#x27;&#123;0&#125;&#x27;, UI group name &#x27;&#123;1&#125;&#x27;, pause covered UI form &#x27;&#123;2&#125;&#x27;, error message &#x27;&#123;3&#125;&#x27;.&quot;</span>, e.UIFormAssetName, e.UIGroupName, e.PauseCoveredUIForm.ToString(), e.ErrorMessage);</span><br><span class="line">    <span class="keyword">if</span> (m_EnableOpenUIFormFailureEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        m_EventComponent.Fire(<span class="keyword">this</span>, OpenUIFormFailureEventArgs.Create(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>再说第二个应用，通过向委托里面添加多个方法，可以实现一个功能的触发，涉及到多个方法的执行。这个从应用上来说其实很好理解，比如游戏中，我使用了恢复血量的药瓶这个道具，那么我的生命值就会进行增加，以及我的敌人会发现我在喝药，并立马进行攻击（bushi）。这种情况其实就是利用一个功能的触发，涉及到多个方法的执行这样的一个原理做到的，这样的功能实现也是建立在委托的支持上的。</p><h3 id="委托的缺点"><a href="#委托的缺点" class="headerlink" title="委托的缺点"></a>委托的缺点</h3><p>封装的矛盾。面向对象设计，讲究的是对象的封装。委托可以很好把方法进行封装，这是毋庸置疑的，但是委托同时还可以被外部直接进行赋值，一旦赋值就会失去原来绑定好的内容，这严重破坏了委托的封装性。<br>而如果把委托设置为Private的话，又会让其完全失去原来的作用。这也是上面GF里面之所以声明委托为Private，并通过事件进行封装对外赋值接口的设计原因。<br>这种情况，就要引入事件这个概念了。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是建立在对委托的语言支持之上的。通过给委托变量加上限制关键词 “event”，就可以声明一个事件。可以理解为声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, MyEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> MyEventHandler MyEvent;</span><br></pre></td></tr></table></figure><p>这样声明的事件，相较于普通的委托变量，有如下几个限制：</p><ol><li>其赋值只能在事件发布者内部进行，外部不能直接赋值。</li><li>其执行只能在事件发布者内部进行，外部不能直接调用。</li></ol><p>通过这种事件的形式，我们可以获取比委托更好的封装性。<br>利用委托的第二个应用，配合上事件，达成的类似喝血瓶的例子这种模式，进行抽象后就是所谓的 “<strong>观察者模式</strong>”，它是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新，是一种 <span style="background-color:rgb(100,200,200,0.5)">松耦合</span> 的设计模式。</p><h2 id="NET框架中的委托与事件"><a href="#NET框架中的委托与事件" class="headerlink" title=".NET框架中的委托与事件"></a>.NET框架中的委托与事件</h2><p>.NET Framework中有着固定的规范：</p><ul><li>命名空间System下存在委托原型定义<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>&lt;<span class="title">TEventArgs</span>&gt;(<span class="params"><span class="built_in">object</span> sender, TEventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>委托类型和变量的名称和都应该以EventHandler结束</li><li>事件的命名为委托去掉EventHandler之后剩余的部分</li><li>继承自 EventArgs 的类型应该以EventArgs 结尾</li></ul><p>看到这个原型定义，可以注意到传参的两个点，一个是传参包含了object sender，另一个是 EventArgs 的类型。sender传递的是事件的发布者，EventArgs 则是事件的附加信息，包含监视者需要用到的信息。<br>EventArgs是存在System命名空间下的一个类，通过继承EventArgs类，可以定义并写入任何自己想要的数据传递给监视者，这一点从上面GF的实例中体现出来的同时，还可以看到对于传递的EventArgs类型，它还拓展进了引用池来保证回收利用。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/delegates-overview">微软官方文档</a></li><li><a href="https://www.lfzxb.top/cdelegate/">烟雨佬的应用说明</a></li><li><a href="https://www.cnblogs.com/SkySoot/archive/2012/04/05/2433639.html">SkyRoot 由浅至深的详解</a></li><li><a href="https://www.bilibili.com/video/BV1LT411L7yv/">关系图取自Witty</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 事件系统 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兴趣使然地开通了自己的博客</title>
      <link href="/2024/10/14/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%951/"/>
      <url>/2024/10/14/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%951/</url>
      
        <content type="html"><![CDATA[<p>随着一个念头的油然而生，此个人博客也被孕育而出。<br></p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>创建一个能自我表达的地方。不知数年过去，想到此番此景又会有何感悟。</li><li>记录并分享学习到的知识点。本人之前的笔记基本上是写在 Notion 上的，笔风相当随意，以自我理解为主要目的。查找资料的时候会看到各种各样的文章和写法，有的大佬的文章对于知识点研究之深，拆解之详细且通俗易懂，让人直呼牛逼，恍然大悟之余也会对所有愿意分享的人心生感谢。倘若自己也能效仿尽一份力，锻炼自己表达能力的同时，也能帮助到他人，则是不胜荣幸。</li></ul><h2 id="博客的搭建"><a href="#博客的搭建" class="headerlink" title="博客的搭建"></a>博客的搭建</h2><p>本博客使用 Hexo 搭建，主题选用的是Butterfly。得力于Hexo的个性化定制功能和Butterfly的简洁美观，本人对于搭建好后的整体展示效果还是比较满意的。<br></p><h3 id="Hexo的优缺点"><a href="#Hexo的优缺点" class="headerlink" title="Hexo的优缺点"></a>Hexo的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>完全免费，整个搭建过程不需要一分钱</td><td>缺少评论，后端等系统，需要手动配置</td></tr><tr><td>上手简单，教程多且细，即使是小白也能轻易实现搭建</td><td>针对问题解决的文章较少</td></tr><tr><td>生成的是静态页面，加载速度快，灵活性强</td><td>对编辑环境有要求，无法通过手机随时随地的编辑和发布</td></tr></tbody></table><h3 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h3><p>网上相关的教程很多，这里就不再赘述了，以下是本人推荐的：</p><ul><li><a href="https://hexo.io/zh-cn/">Hexo官方文档</a></li><li><a href="https://butterfly.js.org/">Butterfly主题官网</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">Hexo博客的基础搭建配置</a></li><li><a href="https://www.drflower.top/posts/5920b38e/">花卷的博客搭建与其风格化配置</a></li><li><a href="https://www.fomal.cc/posts/e593433d.html">Fomalhaut的巨详细搭建教程和主题魔化教程</a></li></ul><p>编辑器本人用的vscode。如果说你没有用过Markdown编写过文档，可以参考其官方文档:</p><ul><li><a href="https://markdown.com.cn/basic-syntax/">Markdown官方文档</a></li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢来捧场的朋友们和不请自来的“阴阳水军”。非常感谢你们平日里的帮助。</p><img src="/img/mushoku.jpg" class="post-image" />]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
