<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#：委托与事件</title>
      <link href="/2024/10/20/CSharp_DelegateAndEvent/"/>
      <url>/2024/10/20/CSharp_DelegateAndEvent/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为接下来想要整理一下游戏里面的事件模块，而当前项目的业务开发都是通过 Lua 进行的，有一阵子没有写 C#了，回想 C#的委托和事件，有些细节一时模糊了起来，所以打算干脆把相关的知识点整理一下，就当做复习了。</p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h3><p>无论是委托还是事件官网都没有一个简单直白的定义，只能说理解万岁。<br></p><blockquote><p>委托：用于封装方法的一种引用类型，类似于 C++的指针，但其类型安全可靠。通过封装多个方法到一个变量中，调用此变量就可以调用所有绑定的方法。你也可以将它理解性地看做“方法的容器”。</p></blockquote><h3 id="委托的写法"><a href="#委托的写法" class="headerlink" title="委托的写法"></a>委托的写法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> ---- 普通写法------</span></span><br><span class="line"><span class="comment">// 1.定义委托类型，这一步定义的是委托的类型，并不是委托的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>()</span>;</span><br><span class="line"><span class="comment">//2.定义委托变量</span></span><br><span class="line"><span class="keyword">public</span> MyEventHandler MyEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛式委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>&gt;(<span class="params">T1 arg1, T2 arg2</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyEventHandler</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; MyEvent</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带返回值的委托，若多个返回值发生，保留最后注册的那个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">MyEventHandler</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T1 arg</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> MyEventHandler&lt;T1, TResult&gt; MyEvent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 匿名方法写法，省去了定义类型的步骤------</span></span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="keyword">public</span> Action MyEventHandler;</span><br><span class="line"><span class="keyword">public</span> Action&lt;<span class="keyword">in</span> T&gt; MyEventHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有返回值</span></span><br><span class="line"><span class="keyword">public</span> Func&lt;<span class="built_in">int</span>&gt; MyEventHandler;</span><br><span class="line"><span class="keyword">public</span> Func&lt;<span class="keyword">in</span> T, <span class="keyword">out</span> TResult&gt; MyEventHandler;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/img/delegateRelation.png" class="post-image" /><h3 id="委托的作用"><a href="#委托的作用" class="headerlink" title="委托的作用"></a>委托的作用</h3><p>熟练使用委托可以提高代码的拓展性，优化代码结构。<br></p><p>这种拓展性的应用场景主要体现在于两个方面：</p><ol><li>代码结构不变的情况，执行处需要在不同的环境下给委托赋值不同的方法，就可以执行不同的功能。</li><li>一个功能的触发，涉及到多个方法的执行。</li></ol><p>先说第一种应用，这里以 GameFramework 框架中的写法举例，在 GameFramework 框架中（后面成为 GF）可以分为 GF 层和 UGF 层，GF 层的逻辑是功能的核心逻辑，而 UGF 层则是 GF 在 Unity 的应用。在 GF 的 UI 模块，一个页面的打开&#x2F;关闭的完成正如其他 UI 框架很可能执行的逻辑一样，通过事件系统派发出了一个 UI 页面打开&#x2F;关闭的事件。而为了保证 GF 层的结构和功能不变动，提供框架使用者可以根据情况自由拓展或者改变这样的操作。GF 层打开&#x2F;关闭页面的 Internal 逻辑执行完成后，并没有直接调用事件模块的接口，而是执行了一个委托。 在 UGF 层，使用者就可以通过绑定自己的方法到这个委托上，来实现自己的页面打开&#x2F;关闭后的处理逻辑，而不会完全不需要接触和改动 GF 层的代码。让我们直接看一下代码写法，<br></p><p>GF层的UIManager:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//GF层，UIManager.cs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义委托，这里你可能觉得诡异，委托的定义居然是使用Private关键字，这个我们在后面事件的时候进行说明</span></span><br><span class="line"><span class="keyword">private</span> EventHandler&lt;OpenUIFormSuccessEventArgs&gt; m_OpenUIFormSuccessEventHandler;</span><br><span class="line"><span class="keyword">private</span> EventHandler&lt;OpenUIFormFailureEventArgs&gt; m_OpenUIFormFailureEventHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供绑定接口，这里通过事件进行绑定，之所以不直接用委托，这个后面说明。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开界面成功事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;OpenUIFormSuccessEventArgs&gt; OpenUIFormSuccess</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormSuccessEventHandler += <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">remove</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormSuccessEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开界面失败事件。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;OpenUIFormFailureEventArgs&gt; OpenUIFormFailure</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">add</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormFailureEventHandler += <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">remove</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_OpenUIFormFailureEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//页面打开或关闭执行对应的委托</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开页面</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InternalOpenUIForm</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//.................省略页面打开成功逻辑......................</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//页面打开逻辑后执行完成回调</span></span><br><span class="line">  <span class="keyword">if</span> (m_OpenUIFormSuccessEventHandler != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      OpenUIFormSuccessEventArgs openUIFormSuccessEventArgs = OpenUIFormSuccessEventArgs.Create(uiForm, duration, userData);</span><br><span class="line">      m_OpenUIFormSuccessEventHandler(<span class="keyword">this</span>, openUIFormSuccessEventArgs);</span><br><span class="line">      ReferencePool.Release(openUIFormSuccessEventArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 关闭界面。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseUIForm</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//.................省略页面关闭成功逻辑......................</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//页面关闭逻辑后执行完成回调</span></span><br><span class="line">  <span class="keyword">if</span> (m_CloseUIFormCompleteEventHandler != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      CloseUIFormCompleteEventArgs closeUIFormCompleteEventArgs = CloseUIFormCompleteEventArgs.Create(uiForm.SerialId, uiForm.UIFormAssetName, uiGroup, userData);</span><br><span class="line">      m_CloseUIFormCompleteEventHandler(<span class="keyword">this</span>, closeUIFormCompleteEventArgs);</span><br><span class="line">      ReferencePool.Release(closeUIFormCompleteEventArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UGF层,UIComponent中的使用形式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --------绑定方法--------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 游戏框架组件初始化。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">base</span>.Awake();</span><br><span class="line">  <span class="comment">//获取GF层的UIManager</span></span><br><span class="line">  m_UIManager = GameFrameworkEntry.GetModule&lt;IUIManager&gt;();</span><br><span class="line">  <span class="keyword">if</span> (m_UIManager == <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      Log.Fatal(<span class="string">&quot;UI manager is invalid.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断绑定需求，如果需要，则绑定事件，这一步使用者就可以根据自己的需求进行自定义功能添加了</span></span><br><span class="line">  <span class="keyword">if</span> (m_EnableOpenUIFormSuccessEvent)</span><br><span class="line">  &#123;</span><br><span class="line">      m_UIManager.OpenUIFormSuccess += OnOpenUIFormSuccess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m_UIManager.OpenUIFormFailure += OnOpenUIFormFailure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------添加的方法--------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件模块，派发UI打开/关闭的事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOpenUIFormSuccess</span>(<span class="params"><span class="built_in">object</span> sender, GameFramework.UI.OpenUIFormSuccessEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_EventComponent.Fire(<span class="keyword">this</span>, OpenUIFormSuccessEventArgs.Create(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOpenUIFormFailure</span>(<span class="params"><span class="built_in">object</span> sender, GameFramework.UI.OpenUIFormFailureEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Log.Warning(<span class="string">&quot;Open UI form failure, asset name &#x27;&#123;0&#125;&#x27;, UI group name &#x27;&#123;1&#125;&#x27;, pause covered UI form &#x27;&#123;2&#125;&#x27;, error message &#x27;&#123;3&#125;&#x27;.&quot;</span>, e.UIFormAssetName, e.UIGroupName, e.PauseCoveredUIForm.ToString(), e.ErrorMessage);</span><br><span class="line">    <span class="keyword">if</span> (m_EnableOpenUIFormFailureEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        m_EventComponent.Fire(<span class="keyword">this</span>, OpenUIFormFailureEventArgs.Create(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>再说第二个应用，通过向委托里面添加多个方法，可以实现一个功能的触发，涉及到多个方法的执行。这个从应用上来说其实很好理解，比如游戏中，我使用了恢复血量的药瓶这个道具，那么我的生命值就会进行增加，以及我的敌人会发现我在喝药，并立马进行攻击（bushi）。这种情况其实就是利用一个功能的触发，涉及到多个方法的执行这样的一个原理做到的，这样的功能实现也是建立在委托的支持上的。</p><h3 id="委托的缺点"><a href="#委托的缺点" class="headerlink" title="委托的缺点"></a>委托的缺点</h3><p>封装的矛盾。面向对象设计，讲究的是对象的封装。委托可以很好把方法进行封装，这是毋庸置疑的，但是委托同时还可以被外部直接进行赋值，一旦赋值就会失去原来绑定好的内容，这严重破坏了委托的封装性。<br>而如果把委托设置为Private的话，又会让其完全失去原来的作用。这也是上面GF里面之所以声明委托为Private，并通过事件进行封装对外赋值接口的设计原因。<br>这种情况，就要引入事件这个概念了。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是建立在对委托的语言支持之上的。通过给委托变量加上限制关键词 “event”，就可以声明一个事件。可以理解为声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, MyEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> MyEventHandler MyEvent;</span><br></pre></td></tr></table></figure><p>这样声明的事件，相较于普通的委托变量，有如下几个限制：</p><ol><li>其赋值只能在事件发布者内部进行，外部不能直接赋值。</li><li>其执行只能在事件发布者内部进行，外部不能直接调用。</li></ol><p>通过这种事件的形式，我们可以获取比委托更好的封装性。<br>利用委托的第二个应用，配合上事件，达成的类似喝血瓶的例子这种模式，进行抽象后就是所谓的 “<strong>观察者模式</strong>”，它是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新，是一种 <span style="background-color:rgb(100,200,200,0.5)">松耦合</span> 的设计模式。</p><h2 id="NET框架中的委托与事件"><a href="#NET框架中的委托与事件" class="headerlink" title=".NET框架中的委托与事件"></a>.NET框架中的委托与事件</h2><p>.NET Framework中有着固定的规范：</p><ul><li>命名空间System下存在委托原型定义<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>&lt;<span class="title">TEventArgs</span>&gt;(<span class="params"><span class="built_in">object</span> sender, TEventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>委托类型和变量的名称和都应该以EventHandler结束</li><li>事件的命名为委托去掉EventHandler之后剩余的部分</li><li>继承自 EventArgs 的类型应该以EventArgs 结尾</li></ul><p>看到这个原型定义，可以注意到传参的两个点，一个是传参包含了object sender，另一个是 EventArgs 的类型。sender传递的是事件的发布者，EventArgs 则是事件的附加信息，包含监视者需要用到的信息。<br>EventArgs是存在System命名空间下的一个类，通过继承EventArgs类，可以定义并写入任何自己想要的数据传递给监视者，这一点从上面GF的实例中体现出来的同时，还可以看到对于传递的EventArgs类型，它还拓展进了引用池来保证回收利用。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/delegates-overview">微软官方文档</a></li><li><a href="https://www.lfzxb.top/cdelegate/">烟雨佬的应用说明</a></li><li><a href="https://www.cnblogs.com/SkySoot/archive/2012/04/05/2433639.html">SkyRoot 由浅至深的详解</a></li><li><a href="https://www.bilibili.com/video/BV1LT411L7yv/">关系图取自Witty</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 事件系统 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兴趣使然地开通了自己的博客</title>
      <link href="/2024/10/14/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%951/"/>
      <url>/2024/10/14/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%951/</url>
      
        <content type="html"><![CDATA[<p>随着一个念头的油然而生，此个人博客也被孕育而出。<br></p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>创建一个能自我表达的地方。不知数年过去，想到此番此景又会有何感悟。</li><li>记录并分享学习到的知识点。本人之前的笔记基本上是写在 Notion 上的，笔风相当随意，以自我理解为主要目的。查找资料的时候会看到各种各样的文章和写法，有的大佬的文章对于知识点研究之深，拆解之详细且通俗易懂，让人直呼牛逼，恍然大悟之余也会对所有愿意分享的人心生感谢。倘若自己也能效仿尽一份力，锻炼自己表达能力的同时，也能帮助到他人，则是不胜荣幸。</li></ul><h2 id="博客的搭建"><a href="#博客的搭建" class="headerlink" title="博客的搭建"></a>博客的搭建</h2><p>本博客使用 Hexo 搭建，主题选用的是Butterfly。得力于Hexo的个性化定制功能和Butterfly的简洁美观，本人对于搭建好后的整体展示效果还是比较满意的。<br></p><h3 id="Hexo的优缺点"><a href="#Hexo的优缺点" class="headerlink" title="Hexo的优缺点"></a>Hexo的优缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>完全免费，整个搭建过程不需要一分钱</td><td>缺少评论，后端等系统，需要手动配置</td></tr><tr><td>上手简单，教程多且细，即使是小白也能轻易实现搭建</td><td>针对问题解决的文章较少</td></tr><tr><td>生成的是静态页面，加载速度快，灵活性强</td><td>对编辑环境有要求，无法通过手机随时随地的编辑和发布</td></tr></tbody></table><h3 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h3><p>网上相关的教程很多，这里就不再赘述了，以下是本人推荐的：</p><ul><li><a href="https://hexo.io/zh-cn/">Hexo官方文档</a></li><li><a href="https://butterfly.js.org/">Butterfly主题官网</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">Hexo博客的基础搭建配置</a></li><li><a href="https://www.drflower.top/posts/5920b38e/">花卷的博客搭建与其风格化配置</a></li><li><a href="https://www.fomal.cc/posts/e593433d.html">Fomalhaut的巨详细搭建教程和主题魔化教程</a></li></ul><p>编辑器本人用的vscode。如果说你没有用过Markdown编写过文档，可以参考其官方文档:</p><ul><li><a href="https://markdown.com.cn/basic-syntax/">Markdown官方文档</a></li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢来捧场的朋友们和不请自来的“阴阳水军”。非常感谢你们平日里的帮助。</p><img src="/img/mushoku.jpg" class="post-image" />]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
